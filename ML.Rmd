---
title: "Machine Learning"
author: "xxx"
date: "2025-07-10"
output: html_document
---

```{r}
# -------------------- INSTALAR Y CARGAR PAQUETES --------------------
required_packages <- c(
  "TCGAbiolinks", "edgeR", "tidyverse", "biomaRt", 
  "uwot", "dbscan", "factoextra", "survival", "survminer", "pheatmap", 
  "SummarizedExperiment"
)

for (pkg in required_packages) {
  if (!require(pkg, character.only = TRUE)) {
    if (pkg %in% rownames(installed.packages()) == FALSE) {
      if (pkg %in% c("TCGAbiolinks", "edgeR", "biomaRt", "SummarizedExperiment")) {
        BiocManager::install(pkg, ask = FALSE)
      } else {
        install.packages(pkg)
      }
    }
    library(pkg, character.only = TRUE)
  }
}

# -------------------- DESCARGA Y PREPROCESADO DE DATOS --------------------
project <- "TCGA-SKCM"

query <- GDCquery(
  project = project,
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  sample.type = "Primary Tumor"
)

GDCdownload(query)
data_se <- GDCprepare(query)

counts <- assay(data_se)

# Normalización
dge <- DGEList(counts = counts)
dge <- calcNormFactors(dge)
cpm_norm <- cpm(dge, normalized.lib.sizes = TRUE)
log2_cpm <- log2(cpm_norm + 1)

# Datos clínicos
clinical_data <- colData(data_se) %>%
  as.data.frame() %>%
  mutate(
    PFS_time = ifelse(vital_status == "Dead", days_to_death, days_to_last_follow_up),
    PFS_status = ifelse(vital_status == "Dead", 1, 0),
    submitter_id_short = substr(barcode, 1, 12)  # IDs cortos TCGA
  )

# -------------------- ANOTACIÓN GENÉTICA --------------------
ensembl_ids <- gsub("\\..*", "", rownames(log2_cpm))

mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

annot <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = unique(ensembl_ids),
  mart = mart
)

expr_df <- as.data.frame(log2_cpm) %>%
  rownames_to_column("ensembl_gene_id") %>%
  mutate(ensembl_gene_id = gsub("\\..*", "", ensembl_gene_id)) %>%
  inner_join(annot, by = "ensembl_gene_id") %>%
  filter(hgnc_symbol != "") %>%
  group_by(hgnc_symbol) %>%
  summarise(across(where(is.numeric), mean)) %>%
  column_to_rownames("hgnc_symbol")

# Guardar resultado para uso posterior
saveRDS(expr_df, file = "log2_cpm_TCGA_SKCM.rds")
saveRDS(clinical_data, file = "clinical_data_TCGA_SKCM.rds")

```


```{r ITH low vs high}
# -------------------- ANÁLISIS ITH: UMAP + CLUSTERING --------------------

# Lista de genes ITH (modificable por el usuario)
genes_ITH <- c(
  "CXCL10", "KIT", "CXCL9", "CXCL1", "BNIP3L", "CCL14", "CXCL2","WNT5B",
  "STAT1", "WNT2", "GBP4", "SOX2","GBP1","SPRY4", "IDO1", "CCL4","MAPK10",
  "ANGPT1", "HMGB1", "CCL18", "CCL20", "OAS3","FAM124B", "IFITM1",  "FCN1",
  "BID",  "CCNA1",  "VCAM1"
)

# Matriz de expresión completa
expr_df_full <- expr_df  # debe existir previamente

# Filtrar genes válidos y transponer
genes_validos_ITH <- intersect(genes_ITH, rownames(expr_df_full))
expr_ITH <- expr_df_full[genes_validos_ITH, , drop = FALSE]
expr_t_ITH <- t(expr_ITH)

# Escalado y PCA
expr_scaled_ITH <- scale(expr_t_ITH)
pc_scores_ITH <- prcomp(expr_scaled_ITH)$x[, 1:min(15, ncol(expr_scaled_ITH))]

# UMAP
set.seed(123)
umap_ITH <- umap(pc_scores_ITH, n_neighbors = 10, min_dist = 0.01, metric = "cosine")

# K-means clustering
km_ITH <- kmeans(umap_ITH, centers = 2, nstart = 25)
clusters_ITH <- factor(km_ITH$cluster)

# Etiquetas genéricas
cluster_labels <- c("1" = "low responder (hipotético)", "2" = "high responder (hipotético)")

df_umap_ITH <- as.data.frame(umap_ITH)
colnames(df_umap_ITH) <- c("UMAP1", "UMAP2")
df_umap_ITH$cluster <- factor(clusters_ITH, levels = c("1", "2"), labels = cluster_labels)
df_umap_ITH$sample <- rownames(expr_t_ITH)

# -------------------- PLOT UMAP --------------------
umap_plot_ith <- ggplot(df_umap_ITH, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_color_manual(values = c("steelblue1", "royalblue4")) +
  theme_minimal(base_size = 14) +
  labs(title = "UMAP genes significativos Inmunoterapia",
       x = "UMAP 1", y = "UMAP 2", color = "Cluster")

ggsave("UMAP_ITH.png", plot = umap_plot_ith, width = 8, height = 6, dpi = 300)

# -------------------- HEATMAP DE EXPRESIÓN --------------------
expr_df_ITH <- as.data.frame(expr_t_ITH)
expr_df_ITH$cluster <- df_umap_ITH$cluster

expr_mean_ITH <- expr_df_ITH %>%
  group_by(cluster) %>%
  summarise(across(where(is.numeric), mean)) %>%
  column_to_rownames("cluster") %>%
  t()

annotation_col_ITH <- data.frame(Cluster = factor(colnames(expr_mean_ITH), levels = cluster_labels))
rownames(annotation_col_ITH) <- colnames(expr_mean_ITH)

annotation_colors_ITH <- list(
  Cluster = c("low responder (hipotético)" = "steelblue1",
              "high responder (hipotético)" = "royalblue4")
)

png("heatmap_ITH.png", width = 1000, height = 1800, res = 150)
pheatmap(expr_mean_ITH,
         scale = "row",
         clustering_method = "complete",
         main = "Expresión media genes ITH",
         fontsize_row = 8,
         fontsize_col = 12,
         annotation_col = annotation_col_ITH,
         annotation_colors = annotation_colors_ITH,
         cellwidth = 100, cellheight = 8)
dev.off()


```





# ==============================
# UMAP y Heatmap para genes BRAF/MEKi
# ==============================
```{r BRAF low vs high}
# -------------------- LIBRERÍAS --------------------
library(caret)
library(dplyr)
library(tibble)
library(randomForest)
library(pROC)
library(ggplot2)
library(e1071)  # SVM
library(uwot)
library(pheatmap)

# -------------------- PREPARACIÓN DE DATOS --------------------
# expr_df_full: matriz de expresión log2 genes x muestras
# cluster_labels: vector de nombres de clusters, p.ej. c("low responder", "high responder")

# -------------------- GENES DE INTERÉS --------------------
genes_BRAF <- c("HLA-DQB1", "COL11A1", "APH1B", "IL12RB2", "HEY1", "IL6", "IL18")

# Filtrar genes presentes en la matriz
genes_validos_BRAF <- intersect(genes_BRAF, rownames(expr_df_full))
expr_BRAF <- expr_df_full[genes_validos_BRAF, , drop = FALSE]

# Transponer para que filas = muestras, columnas = genes
expr_t_BRAF <- t(expr_BRAF)

# Escalar datos
expr_scaled_BRAF <- scale(expr_t_BRAF)

# PCA previo a UMAP
pc_scores_BRAF <- prcomp(expr_scaled_BRAF)$x[, 1:6]

# UMAP
set.seed(123)
umap_BRAF <- umap(pc_scores_BRAF, n_neighbors = 10, min_dist = 0.01, metric = "cosine")

# Clustering (k-means)
set.seed(123)
km_BRAF <- kmeans(umap_BRAF, centers = 2, nstart = 25)
clusters_BRAF <- factor(km_BRAF$cluster)

# -------------------- DATAFRAME PARA PLOTEAR --------------------
df_umap_BRAF <- as.data.frame(umap_BRAF)
colnames(df_umap_BRAF) <- c("UMAP1", "UMAP2")
df_umap_BRAF$cluster <- factor(clusters_BRAF, levels = c("1", "2"), labels = cluster_labels)
df_umap_BRAF$sample <- rownames(expr_t_BRAF)

# -------------------- PLOT UMAP --------------------
umap_plot_braf <- ggplot(df_umap_BRAF, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(alpha = 0.8, size = 3) +
  scale_color_manual(values = c("plum", "slateblue")) +
  theme_minimal(base_size = 14) +
  labs(title = "UMAP de genes significativos BRAF/MEKi",
       x = "UMAP 1", y = "UMAP 2", color = "Cluster")

ggsave("UMAP_BRAF_MEK.png", plot = umap_plot_braf, width = 8, height = 6, dpi = 300)

# -------------------- HEATMAP --------------------
# Añadir cluster a matriz de expresión
expr_df_BRAF <- as.data.frame(expr_t_BRAF)
expr_df_BRAF$cluster <- df_umap_BRAF$cluster

# Calcular expresión media por cluster
expr_mean_BRAF <- expr_df_BRAF %>%
  group_by(cluster) %>%
  summarise(across(where(is.numeric), mean)) %>%
  column_to_rownames("cluster") %>%
  t()

# Anotaciones para heatmap
annotation_col_BRAF <- data.frame(Cluster = factor(colnames(expr_mean_BRAF), levels = cluster_labels))
rownames(annotation_col_BRAF) <- colnames(expr_mean_BRAF)

annotation_colors_BRAF <- list(
  Cluster = c("low responder" = "plum", "high responder" = "slateblue")
)

# Guardar heatmap
png("heatmap_BRAF_MEK.png", width = 1200, height = 800, res = 150)
pheatmap(expr_mean_BRAF,
         scale = "row",
         clustering_method = "complete",
         main = "Expresión media por cluster",
         fontsize_row = 8,
         fontsize_col = 12,
         annotation_col = annotation_col_BRAF,
         annotation_colors = annotation_colors_BRAF,
         cellwidth = 100, cellheight = 8)
dev.off()
```



```{r confusion matrix}
library(dplyr)
library(ggplot2)

# Crear columna de respuestas conjuntas
df_clusters <- df_clusters %>%
  mutate(
    Respuesta_Conjunta = case_when(
      Cluster_ITH == "high" & Cluster_BRAF == "high" ~ "doble respondedores",
      Cluster_ITH == "low" & Cluster_BRAF == "low" ~ "doble refractarios",
      Cluster_ITH == "high" & Cluster_BRAF == "low" ~ "respondedores ITH",
      Cluster_ITH == "low" & Cluster_BRAF == "high" ~ "respondedores BRAF/MEKi",
      TRUE ~ "otros"
    )
  )

# Tabla resumen
tabla_counts <- table(df_clusters$Respuesta_Conjunta)
tabla_pct <- round(100 * tabla_counts / sum(tabla_counts), 2)
tabla_resumen <- data.frame(
  Categoria = names(tabla_counts),
  Conteo = as.vector(tabla_counts),
  Porcentaje = as.vector(tabla_pct)
)

# Guardar CSV
write.csv(tabla_resumen, "tabla_resumen_respuestas.csv", row.names = FALSE)

# Gráfico de barras
png("grafico_respuesta_conjunta.png", width = 1500, height = 1200, res = 150)
ggplot(tabla_resumen, aes(x = reorder(Categoria, -Porcentaje), y = Porcentaje, fill = Categoria)) +
  geom_col(color = "black", alpha = 0.85) +
  geom_text(aes(label = paste0(Porcentaje, "%")), vjust = -0.5, size = 5) +
  scale_fill_manual(values = c(
    "doble respondedores" = "lightgreen",
    "doble refractarios" = "hotpink1",
    "respondedores ITH" = "#3B82F6",
    "respondedores BRAF/MEKi" = "#9F7AEA",
    "otros" = "#B3AEDC"
  )) +
  theme_minimal(base_size = 16) +
  labs(
    title = "Distribución de respuestas conjuntas (ITH y BRAF/MEKi)",
    x = "Categoría de Respuesta",
    y = "Porcentaje (%)",
    fill = "Categoría"
  ) +
  theme(axis.text.x = element_text(angle = 25, hjust = 1))
dev.off()

```



