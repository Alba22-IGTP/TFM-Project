---
title: "Análisis Completo de Datos NanoString IO 360"
author: "Alba"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: true
    theme: cosmo
    highlight: tango
    code_folding: show
    df_print: paged
    self_contained: true
lang: es
---

Este informe detalla la Normalización y control de calidad de un ensayo de Nanostring Immune-Oncology 360. Se ha usado la herramienta de BioConductor https://bioconductor.org/packages/release/bioc/html/NanoStringNCTools.html para realizar las normalizaciónes (nCounter y SizeFactors) y el control de calidad.

1. **Instalación y carga de paquetes**:
    
    ```{r Packages}
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }

    required_packages <- c("NanoStringNCTools", "ggplot2", "ggiraph", "dplyr", "tibble", "readr", "tidyr", "RColorBrewer", "patchwork", "gridExtra", "GeomxTools", "pheatmap", "corrplot", "sva", "Biobase", "cluster", "merTools", "lme4", "reshape2", "limma", "ggrepel", "DESeq2")
    for (pkg in required_packages) {
      if (!requireNamespace(pkg, quietly = TRUE)) {
        BiocManager::install(pkg)
      }
      library(pkg, character.only = TRUE)
    }
    ```

2. **Defino el directorio de trabajo**:
    
    ```{r Directory}
    datadir <- "C:/Users/adelapuente/Desktop/TFM/Nanostring/Rawdata"
    ```


3. **Preparamos archivos de trabajo**

3.1. **Leemos y mnodificamos el archivo 'sample annotation'**:
    
    ```{r Sample annotation}
    rlf_file <- file.path(datadir, "NS_IO_360_v1.0.rlf")
    sample_annotation <- file.path(datadir, "NS_IO_360_v1.03runs_.csv")

    read_sample_annotation <- function(file_path) {
      sample_data <- read.csv(file_path, check.names = FALSE, stringsAsFactors = FALSE, header = FALSE)
      sample_data_t <- as.data.frame(t(sample_data), stringsAsFactors = FALSE)
      colnames(sample_data_t) <- sample_data_t[1, ]
      sample_data_t <- sample_data_t[-1, ]

      if (all(c("File Name", "Sample ID") %in% colnames(sample_data_t))) {
        sample_data_t <- sample_data_t[, c("File Name", "Sample ID")]
      } else {
        stop("Las columnas 'File Name' y/o 'Sample ID' no se encuentran en el archivo CSV.")
      }

      sample_data_t <- sample_data_t[!is.na(sample_data_t$`File Name`) & sample_data_t$`File Name` != "", ]
      sample_data_t <- sample_data_t[!is.na(sample_data_t$`Sample ID`) & sample_data_t$`Sample ID` != "", ]

      return(sample_data_t)
    }

    sample_data_t <- read_sample_annotation(sample_annotation)
    ```

3.2. **Cargamos los archivos RCC**:
    
    ```{r RCC files}
    rcc_files <- list.files(datadir, pattern = "\\.RCC$", full.names = TRUE)
    rcc_names <- basename(rcc_files)
    missing_files <- setdiff(sample_data_t$`File Name`, rcc_names)
    if (length(missing_files) > 0) {
      warning("Los siguientes archivos en 'File Name' no coinciden con los archivos RCC en el directorio:\n", 
              paste(missing_files, collapse = "\n"))
    } else {
      message("Todos los archivos en 'File Name' coinciden con los archivos RCC.")
    }
    ```



4.  **Creamos el archivo NanoStringSet**:
    
    ```{r NanoStringSet object}

    temp_annotation_file <- tempfile(fileext = ".csv")
    write.csv(sample_data_t, temp_annotation_file, row.names = FALSE)

    nanoStringData <- readNanoStringRccSet(rcc_files, rlfFile = rlf_file, 
                                           phenoDataFile = temp_annotation_file,
                                           phenoDataRccColName = "File Name")
    
class(nanoStringData)
isS4(nanoStringData)
is(nanoStringData, "ExpressionSet")
nanoStringData
    ```
    
4.1. **Resumen de los datos de nCounter**:
 
```{r nCounter data}
# summarize log2 counts for each feature
head(summary(nanoStringData, MARGIN = 1), 2)

# summarize log2 counts for each sample
head(summary(nanoStringData, MARGIN = 2), 2)

```

4.2. **Subsetting de los objetos de NanoStringRCCSet**:

```{r NanoStringRCCSet subsetting}
# check the number of samples in the dataset
length(sampleNames(nanoStringData))

# check the dimension of the expression matrix
dim(exprs(nanoStringData))

# housekeepingSubset() only selects housekeeper genes
with(housekeepingSubset(nanoStringData), table(CodeClass))

# negativeControlSubset() only selects negative probes
with(negativeControlSubset(nanoStringData), table(CodeClass))

# positiveControlSubset() only selects positive probes
with(positiveControlSubset(nanoStringData), table(CodeClass))

# controlSubset() selects all control probes
with(controlSubset(nanoStringData), table(CodeClass))

# nonControlSubset() selects all non-control probes
with(nonControlSubset(nanoStringData), table(CodeClass))

```

5. **Control de calidad. Negative Controls**:
    
```{r Quality Control}
# negativeControlSubset() only selects negative probes
with(negativeControlSubset(nanoStringData), table(CodeClass))
    
    neg_set <- negativeControlSubset(nanoStringData)
class(neg_set)

# Use the setSeqQCFlags function to set Sequencing QC Flags to your dataset. The default cutoff are displayed in the function. 
nanoStringData <- setQCFlags(nanoStringData,
                       qcCutoffs = list(Housekeeper = c(failingCutoff = 32, passingCutoff = 100), 
                                        Imaging = c(fovCutoff = 0.75), 
                                        BindingDensity = c(minimumBD = 0.1, maximumBD = 2.25, maximumBDSprint = 1.8), 
                                        ERCCLinearity = c(correlationValue = 0.95), 
                                        ERCCLoD = c(standardDeviations = 2)))

# show the last 6 column names in the data
tail(svarLabels(nanoStringData))

# show the first 2 rows of the QC Flags results
protocolData(nanoStringData)
head(protocolData(nanoStringData)[["QCFlags"]])

# show the first 2 rows of the QC Borderline Flags results
head(protocolData(nanoStringData)[["QCBorderlineFlags"]])


girafe(ggobj = autoplot(nanoStringData, type = "housekeep-geom"))



girafe(ggobj = autoplot(nanoStringData, type = "lane-bindingDensity"))


girafe(ggobj = autoplot(nanoStringData, type = "lane-fov"))


girafe(ggobj = autoplot(nanoStringData, type = "ercc-linearity"))


girafe(ggobj = autoplot(nanoStringData, type = "ercc-lod"))

girafe(ggobj = autoplot(nanoStringData, "boxplot-feature", index = featureNames(nanoStringData)[3], elt = "exprs"))


#crear tabla
# Extraer los nombres de las muestras
sample_names <- sampleNames(nanoStringData)

# Extraer las QCFlags y QCBorderlineFlags
qc_flags <- protocolData(nanoStringData)[["QCFlags"]]
qc_borderline_flags <- protocolData(nanoStringData)[["QCBorderlineFlags"]]

# Combinar los nombres de las muestras con las flags en un data frame
flags_table <- data.frame(
  SampleName = sample_names,
  QCFlags = qc_flags,
  QCBorderlineFlags = qc_borderline_flags
)

# Mostrar las primeras filas de la tabla
head(flags_table)


```

6.  **Exploración de los datos crudos**

6.1 **Grafico distribución genes por paciente** 
```{r Gene counts distribution}
# Convertir los datos normalizados a formato largo
data_df <- as.data.frame(nanoStringData)

# Identificar las columnas de expresión (por ejemplo, todas las que empiezan con 'Endogenous_')
expr_cols <- grep("^Endogenous_", colnames(data_df), value = TRUE)

# Convertir solo esas columnas a formato largo
data_long <- pivot_longer(data_df, 
                          cols = all_of(expr_cols),
                          names_to = "Gene",
                          values_to = "Expression")

# Verificar los nombres de las columnas
colnames(data_long)

# Generar una paleta de colores con tantos colores como muestras únicas
n_samples <- length(unique(data_long$Sample.ID))

blues <- colorRampPalette(c("#08306B", "#4292C6", "#9ECAE1"))(12)
purples <- colorRampPalette(c("#54278F", "#9E9AC8", "#DADAEB"))(12)
pinks <- colorRampPalette(c("#7A0177", "#C51B8A", "#FCC5C0"))(11)

color_palette <- c(blues, purples, pinks)


# Gráfico
expression_plot <- ggplot(data_long, aes(x = Sample.ID, y = Expression, fill = Sample.ID)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.8) +
  scale_fill_manual(values = color_palette) + # Usamos la paleta ajustada
  theme_minimal() +
  labs(title = "Distribución de expresión",
       x = "Muestras", 
       y = "Expresión") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        legend.position = "none") +
  scale_y_continuous(limits = c(0, 2000))  # Ajustar límites de expresión


# Mostrar el gráfico
print(expression_plot)


# Exportar con alta calidad
ggsave(
  filename = "boxplot_expresion_31muestras.png",
  plot = expression_plot,
  device = "png",
  width = 14,        # Ancho para acomodar las 31 muestras
  height = 7,
  units = "in",
  dpi = 300,
  bg = "white"
)


```

6.2  **Grafico counts totales por muestra** 
```{r Gene counts}

# Asegurarte de que color_palette tiene suficientes colores
blues <- colorRampPalette(c("#08306B", "#4292C6", "#9ECAE1"))(12)
purples <- colorRampPalette(c("#54278F", "#9E9AC8", "#DADAEB"))(12)
pinks <- colorRampPalette(c("#7A0177", "#C51B8A", "#FCC5C0"))(11)

color_palette <- c(blues, purples, pinks)

# Calcular los counts totales por muestra
total_counts_df <- data_long %>%
  group_by(Sample.ID) %>%
  summarise(TotalCounts = sum(Expression, na.rm = TRUE)) %>%
  ungroup()

# Gráfico con colores personalizados por muestra
total_counts_plot <- ggplot(total_counts_df, aes(x = Sample.ID, y = TotalCounts, fill = Sample.ID)) +
  geom_bar(stat = "identity", alpha = 0.8) +
  scale_fill_manual(values = color_palette) +
  theme_minimal() +
  labs(title = "Counts totales por muestra (31 muestras)",
       x = "Muestras", 
       y = "Counts totales") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        legend.position = "none") +
  geom_text(aes(label = round(TotalCounts)), vjust = -0.5, size = 3)

# Mostrar el gráfico
print(total_counts_plot)

# Exportar
ggsave(
  filename = "total_counts_31muestras.png",
  plot = total_counts_plot,
  device = "png",
  width = 14,
  height = 7,
  units = "in",
  dpi = 300,
  bg = "white"
)



```

6.3  **0 per sample**
```{r 0 per sample}

# Obtener la matriz de counts
count_matrix <- exprs(nanoStringData)

# Crear un data frame que indique qué genes tienen 0 counts en cada muestra
zero_counts <- as.data.frame(count_matrix == 0)
names(zero_counts) <- sampleNames(nanoStringData)
rownames(zero_counts) <- featureNames(nanoStringData)

# Calcular el número de genes con 0 counts por muestra
zero_counts_summary <- colSums(zero_counts)

print(zero_counts_summary)

# Encontrar genes que tienen 0 counts en al menos una muestra
genes_with_zero <- zero_counts[rowSums(zero_counts) > 0, ]

# Opcional: ordenar por frecuencia de ceros
genes_with_zero <- genes_with_zero[order(rowSums(genes_with_zero), decreasing = TRUE), ]

print(genes_with_zero)

# Exportar el resumen de conteos cero por muestra
write.csv(data.frame(Sample = names(zero_counts_summary), 
                    Genes_with_zero_counts = zero_counts_summary),
          file = "zero_counts_summary.csv", 
          row.names = FALSE)

# Exportar la matriz detallada de qué genes tienen 0 counts en qué muestras
write.csv(genes_with_zero, file = "genes_with_zero_counts.csv")



```




6.4  **KDE Plot**
```{r KDE Plot}

# Extraer los datos de expresión (genes x muestras)
exprs_data <- exprs(nanoStringData)

# Paso: Convertir la matriz de expresión a formato largo (long format)
exprs_df <- as.data.frame(exprs_data)
exprs_long <- gather(exprs_df, key = "Sample", value = "Expression", 1:ncol(exprs_df))

# Agregar la columna de Gene
exprs_long$Gene <- rep(rownames(exprs_data), each = ncol(exprs_data))

# Ver los primeros registros para asegurarse de que los datos estén correctamente estructurados
head(exprs_long)

# Crear el gráfico
plot_densidad <- ggplot(exprs_long, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) +
  scale_x_continuous(limits = c(-500, 500)) +
  theme_minimal() +
  labs(title = "Distribución de la expresión de genes por muestra",
       x = "Expresión de genes (counts)",
       y = "Densidad") +
  theme(legend.position = "none")

# Mostrar el gráfico en pantalla
print(plot_densidad)  # Esto hará que aparezca en tu panel de 'Plots' de RStudio

# Exportar en alta resolución 
ggsave(
  filename = "densidad_expresion_genes.png",  # Nombre del archivo
  plot = plot_densidad,                      # Objeto ggplot
  device = "png",                            # Formato (también puede ser "pdf", "jpeg", etc.)
  width = 10,                                # Ancho en pulgadas
  height = 6,                                # Alto en pulgadas
  units = "in",                              # Unidades (pulgadas)
  dpi = 300                                  # Resolución (puntos por pulgada)
)



```



6.5  **KDE Plot: Muestras QCBorderlineFlag**
```{r KDE Plot: QCBlFlags}

# 1. Calcular métricas de distribución
dist_metrics <- exprs_long %>%
  group_by(Sample) %>%
  summarize(
    Mediana = median(Expression),
    MAD = mad(Expression),
    Distancia_KS = ks.test(Expression, ecdf(exprs_long$Expression))$statistic
  ) %>%
  arrange(desc(Distancia_KS))

# 2. Identificar muestras atípicas (top 8%)
umbral <- quantile(dist_metrics$Distancia_KS, 0.92)
muestras_atipicas <- dist_metrics %>% 
  filter(Distancia_KS > umbral) %>% 
  pull(Sample)

# Paleta de colores personalizada
colores_atipicas <- c(
  "#FF6B9E",  # Rosa vibrante
  "#47B8E0",  # Azul claro
  "#7CBE7B"   # Verde fresco
)

# 3. Visualización con colores personalizados
ggplot(exprs_long, aes(x = Expression)) +
  # Muestras normales (fondo)
  geom_density(data = subset(exprs_long, !(Sample %in% muestras_atipicas)), 
               color = "gray90", alpha = 0.2, linewidth = 0.5) +
  
  # Muestras atípicas (resaltadas)
  geom_density(data = subset(exprs_long, Sample %in% muestras_atipicas),
               aes(color = Sample, fill = Sample), 
               alpha = 0.3, linewidth = 1.2) +
  
  # Escalas y límites
  scale_x_continuous(limits = c(-500, 3000)) +
  scale_color_manual(values = colores_atipicas) +
  scale_fill_manual(values = colores_atipicas) +
  
  # Etiquetas y tema
  labs(title = paste("Muestras con distribución atípica (", length(muestras_atipicas), " muestras)"),
       subtitle = "Basado en la distancia de Kolmogorov-Smirnov",
       x = "Expresión génica (counts)",
       y = "Densidad",
       caption = paste("Muestras:", paste(muestras_atipicas, collapse = ", "))) +
  
  theme_minimal() +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 14, color = "#333333"),
    plot.subtitle = element_text(size = 11, color = "#666666"),
    legend.title = element_blank()
  )

# Exportar el gráfico
ggsave("muestras_atipicas_colores.png", 
       width = 10, height = 6, 
       dpi = 300, bg = "white")
```


6.6  **KDE Plot: muestras problematicas**
```{r KDE Plot: problematic samples}

# Seleccionar las muestras que deseas incluir
included_samples <- c("20220215_IO360melRunC_GEM36_06.RCC", 
                      "20210316_IO360melRunA_GEM4_03.RCC", 
                      "20210316_IO360melRunA_GEM17_09.RCC", 
                      "20210316_IO360melRunA_GEM12_06.RCC")

# Filtrar los datos para incluir solo las muestras seleccionadas
exprs_long_included <- exprs_long[exprs_long$Sample %in% included_samples, ]

# Filtrar los datos para excluir las muestras seleccionadas
exprs_long_excluded <- exprs_long[!exprs_long$Sample %in% included_samples, ]


# Crear el gráfico para las muestras seleccionadas
plot_included <- ggplot(exprs_long_included, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) +  # Curvas de densidad con transparencia
  scale_x_continuous(limits = c(-500, 3000)) +  # Limitar el rango del eje X
  theme_minimal() +
  labs(title = "Distribución de la expresión de genes QCBorderlineFlag Samples",
       x = "Expresión de genes (counts)",
       y = "Densidad") +
  theme(legend.position = "none")  # Eliminar la leyenda

# Crear el gráfico para las muestras excluidas
plot_excluded <- ggplot(exprs_long_excluded, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) +  # Curvas de densidad con transparencia
  scale_x_continuous(limits = c(-500, 3000)) +  # Limitar el rango del eje X
  theme_minimal() +
  labs(title = "Distribución de la expresión de genes para muestras sin Flags",
       x = "Expresión de genes (counts)",
       y = "Densidad") +
  theme(legend.position = "none")  # Eliminar la leyenda

# Combine plots side by side with patchwork
combined_plots <- plot_included + plot_excluded +
  plot_annotation(title = "Comparación de distribuciones de expresión",
                  subtitle = "Análisis de control de calidad",
                  theme = theme(plot.title = element_text(size = 14, face = "bold")))

print(combined_plots)

# Export the combined plot
ggsave("comparacion_muestras_incluidas_excluidas.png",
       plot = combined_plots,
       width = 14,  # Wider to accommodate two plots
       height = 6,
       dpi = 300,
       bg = "white")

```


6.7 **Correlation plot before normalization**
```{r Corr plot: raw data}

analyze_gene_class <- function(nanoStringData, gene_class, title_name) {
  # Extract data
  counts_totales <- colSums(exprs(nanoStringData))
  
  # Determine the prefix based on gene class
  prefix <- switch(gene_class,
                  "Positive" = "POS_",
                  "Negative" = "NEG_",
                  "Housekeeping" = "Housekeeping_",
                  "")
  
  class_expr <- exprs(nanoStringData)[fData(nanoStringData)$CodeClass == gene_class, ]
  
  # Modify sample names to keep only _GEM_ part
  modified_sample_names <- sapply(colnames(class_expr), function(x) {
    parts <- unlist(strsplit(x, "_"))
    gem_part <- parts[grep("GEM", parts)]
    if(length(gem_part) > 0) gem_part else x
  })
  
  colnames(class_expr) <- modified_sample_names
  
  # Boxplot of distribution across samples
  df_box <- as.data.frame(t(class_expr))
  df_box$Muestra <- rownames(df_box)
  df_long_box <- gather(df_box, key = "Gene", value = "Count", -Muestra)
  
  p_box <- ggplot(df_long_box, aes(x = Muestra, y = Count, fill = Muestra)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Distribución de", title_name, "(Datos Crudos)"),
      subtitle = "Distribución entre muestras",
      x = "Muestra",
      y = "Counts (log10)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
      legend.position = "none"
    ) +
    scale_fill_manual(values = color_palette)
  
  # Modify gene names to remove class prefix and anything after NM if present
  modified_gene_names <- sapply(rownames(class_expr), function(x) {
    # Remove prefix
    x_no_prefix <- sub(paste0("^", prefix), "", x)
    # Remove _NM suffix if present
    sub("_NM.*$", "", x_no_prefix)
  })
  
  rownames(class_expr) <- modified_gene_names
  
  # Correlation plot
  df_cor <- data.frame(
    Muestra = colnames(class_expr),
    Counts_Totales = counts_totales,
    t(class_expr)
  ) %>% 
    pivot_longer(
      cols = -c(Muestra, Counts_Totales),
      names_to = "Gene",
      values_to = "Expresion"
    ) %>% 
    group_by(Gene) %>% 
    mutate(
      Correlacion = cor(Counts_Totales, Expresion, method = "spearman"),
      Etiqueta_r = paste0("r = ", round(Correlacion, 2))
    ) %>% 
    ungroup()
  
  # Calculate positions for r labels
  label_data <- df_cor %>%
    group_by(Gene) %>%
    summarize(
      Correlacion = dplyr::first(Correlacion),
      Etiqueta_r = dplyr::first(Etiqueta_r),
      Counts_Totales = max(Counts_Totales) * 0.7,
      Expresion = max(Expresion) * (1 - 0.1 * cur_group_id())
)

  
  p_cor <- ggplot(df_cor, aes(x = Counts_Totales, y = Expresion, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_data,
      aes(x = Counts_Totales, y = Expresion, label = Etiqueta_r),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_continuous(labels = scales::comma, trans = "log10") +
    scale_y_continuous(trans = "log10") +
    labs(
      title = paste("Expresión de", title_name, "vs. Counts Totales"),
      subtitle = "Relación con el total de counts por muestra",
      x = "Counts Totales (log10)",
      y = paste("Expresión de", title_name, "(log10)"),
      color = title_name
    ) +
    theme_bw() +
    theme(
      legend.position = "right",
      panel.grid.minor = element_blank()
    ) +
    scale_fill_manual(values = color_palette)
  
  # Correlation table
  cor_table <- df_cor %>% 
    distinct(Gene, Correlacion) %>% 
    arrange(desc(Correlacion))
  
  # Return results
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table
  )
}



# Analyze all three gene classes with correct prefixes
positive_results <- analyze_gene_class(nanoStringData, "Positive", "Controles Positivos")
housekeeping_results <- analyze_gene_class(nanoStringData, "Housekeeping", "Genes Housekeeping")
negative_results <- analyze_gene_class(nanoStringData, "Negative", "Controles Negativos")

# Display all plots
positive_results$boxplot
positive_results$correlation_plot
print(positive_results$correlation_table)

housekeeping_results$boxplot
housekeeping_results$correlation_plot
print(housekeeping_results$correlation_table)

negative_results$boxplot
negative_results$correlation_plot
print(negative_results$correlation_table)

# Crear un directorio para los resultados si no existe
if(!dir.exists("QC_Results")) {
  dir.create("QC_Results")
}

pdf(file.path("QC_Results", "All_QC_Plots.pdf"), width = 10, height = 8)
print(positive_results$boxplot)
print(positive_results$correlation_plot)
print(housekeeping_results$boxplot)
print(housekeeping_results$correlation_plot)
print(negative_results$boxplot)
print(negative_results$correlation_plot)
dev.off()

```



7. **Normalizamos Data**

7.1 **Positive Controls**:
```{r Normalization}
# 1. QUALITY CONTROL AND NORMALIZATION

# Check control probes
with(positiveControlSubset(nanoStringData), table(CodeClass))

# COMPREHENSIVE NORMALIZATION
nanoStringData_norm <- normalize(
  nanoStringData,
  type = "nSolver",
  fromELT = "exprs",
  toELT = "exprs_norm",
  background = "mean.2sd",               # Background subtraction
  normTo = "housekeeping.geo.mean",      # Housekeeping normalization
  take.log = FALSE,                       # Log2 transformation
  return.matrix.of.endogenous.probes = FALSE,
  keep.other = TRUE
)

# QC: Check normalization results
print(head(summary(nanoStringData_norm, MARGIN = 2), 6))
print(head(pData(nanoStringData_norm)))


# VISUALIZATION OF NORMALIZED DATA
# Heatmap of top genes
autoplot(nanoStringData_norm, 
         type = "heatmap-genes", 
         elt = "exprs_norm",
         heatmapGroup = "Sample ID",
         show_colnames_gene_limit = 10,
         show_rownames_gene_limit = 40,
         log2scale = FALSE)

# Boxplot of expression distribution
girafe(ggobj = autoplot(nanoStringData_norm, 
                       "boxplot-feature", 
                       index = featureNames(nanoStringData_norm)[3], 
                       elt = "exprs"))

# Extraer matriz de expresión normalizada
exprs_matrix <- assay(nanoStringData_norm, "exprs_norm")



```

7.2 **Correlation Plot**
```{r Corr plot: after normalization}

# Function to create plots and correlations for a given gene class
analyze_gene_class <- function(nanoStringData_norm, gene_class, title_name) {
  # Extract data
  counts_totales <- colSums(exprs(nanoStringData_norm))
  class_expr <- exprs(nanoStringData_norm)[fData(nanoStringData_norm)$CodeClass == gene_class, ]
  
  # Determine the prefix based on gene class
  prefix <- switch(gene_class,
                  "Positive" = "POS_",
                  "Negative" = "NEG_",
                  "Housekeeping" = "Housekeeping_",
                  "")
  
  # Modify sample names to keep only _GEM_ part
  modified_sample_names <- sapply(colnames(class_expr), function(x) {
    parts <- unlist(strsplit(x, "_"))
    gem_part <- parts[grep("GEM", parts)]
    if(length(gem_part) > 0) gem_part else x
  })
  
  colnames(class_expr) <- modified_sample_names
  
  # Boxplot of distribution across samples
  df_box <- as.data.frame(t(class_expr))
  df_box$Muestra <- rownames(df_box)
  df_long_box <- gather(df_box, key = "Gene", value = "Count", -Muestra)
  
  p_box <- ggplot(df_long_box, aes(x = Muestra, y = Count, fill = Muestra)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Distribución de", title_name, "(Datos Normalizados)"),
      subtitle = "Distribución entre muestras",
      x = "Muestra",
      y = "Counts (log10)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
      legend.position = "none"
    ) +
    scale_fill_manual(values = color_palette)
  
  # Modify gene names to remove class prefix and anything after NM if present
  modified_gene_names <- sapply(rownames(class_expr), function(x) {
    # Remove prefix
    x_no_prefix <- sub(paste0("^", prefix), "", x)
    # Remove _NM suffix if present
    sub("_NM.*$", "", x_no_prefix)
  })
  
  rownames(class_expr) <- modified_gene_names
  
  # Correlation plot
  df_cor <- data.frame(
    Muestra = colnames(class_expr),
    Counts_Totales = counts_totales,
    t(class_expr)
  ) %>% 
    pivot_longer(
      cols = -c(Muestra, Counts_Totales),
      names_to = "Gene",
      values_to = "Expresion"
    ) %>% 
    group_by(Gene) %>% 
    mutate(
      Correlacion = cor(Counts_Totales, Expresion, method = "spearman"),
      Etiqueta_r = paste0("r = ", round(Correlacion, 2))
    ) %>% 
    ungroup()
  
  # Calculate positions for r labels
  label_data <- df_cor %>%
    group_by(Gene) %>%
    summarize(
      Correlacion = dplyr::first(Correlacion),
      Etiqueta_r = dplyr::first(Etiqueta_r),
      Counts_Totales = max(Counts_Totales) * 0.7,
      Expresion = max(Expresion) * (1 - 0.1 * cur_group_id())
)
  
  p_cor <- ggplot(df_cor, aes(x = Counts_Totales, y = Expresion, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_data,
      aes(x = Counts_Totales, y = Expresion, label = Etiqueta_r),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_continuous(labels = scales::comma, trans = "log10") +
    scale_y_continuous(trans = "log10") +
    labs(
      title = paste("Expresión de", title_name, "vs. Counts Totales"),
      subtitle = "Relación con el total de counts por muestra",
      x = "Counts Totales (log10)",
      y = paste("Expresión de", title_name, "(log10)"),
      color = title_name
    ) +
    theme_bw() +
    theme(
      legend.position = "right",
      panel.grid.minor = element_blank()
    ) +
    scale_fill_manual(values = color_palette)
  
  # Correlation table
  cor_table <- df_cor %>% 
    distinct(Gene, Correlacion) %>% 
    arrange(desc(Correlacion))
  
  # Return results
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table
  )
}

# Analyze all three gene classes with correct prefixes
positive_results <- analyze_gene_class(nanoStringData_norm, "Positive", "Controles Positivos")
housekeeping_results <- analyze_gene_class(nanoStringData_norm, "Housekeeping", "Genes Housekeeping")
negative_results <- analyze_gene_class(nanoStringData_norm, "Negative", "Controles Negativos")

# Display all plots
positive_results$boxplot
positive_results$correlation_plot
print(positive_results$correlation_table)

housekeeping_results$boxplot
housekeeping_results$correlation_plot
print(housekeeping_results$correlation_table)

negative_results$boxplot
negative_results$correlation_plot
print(negative_results$correlation_table)


# Crear un directorio para los resultados si no existe
if(!dir.exists("QC_Results")) {
  dir.create("QC_Results")
}

pdf(file.path("QC_Results", "All_QC_Plots_after_norm.pdf"), width = 15, height = 8)
print(positive_results$boxplot)
print(positive_results$correlation_plot)
print(housekeeping_results$boxplot)
print(housekeeping_results$correlation_plot)
print(negative_results$boxplot)
print(negative_results$correlation_plot)
dev.off()

```

7.3 **Normalización por Size Factor**
```{r Corrección por Size Factors}
# First, extract your normalized expression data from the NanoString object
# Assuming you want to work with the endogenous genes
norm_data <- exprs(nanoStringData_norm)  # Or exprs_norm if you used that slot

# Calculate size factors from the ORIGINAL counts (not normalized)
# You'll need to access the original count data first
original_data <- exprs(nanoStringData)  # Original counts

calculate_size_factors <- function(counts) {
  # Función para calcular factores de tamaño estilo DESeq
  log_counts <- log(counts)
  log_geo_means <- rowMeans(log_counts)
  
  size_factors <- apply(counts, 2, function(col) {
    exp(median((log(col) - log_geo_means)[is.finite(log_geo_means)]))
  })
  
  return(size_factors)
}

size_factors <- calculate_size_factors(original_data)

# Apply size factor normalization to your ALREADY NORMALIZED data
# Note: This applies size factors as an additional normalization step
final_norm_data <- sweep(norm_data, 2, size_factors, "/")

# Visualization
par(mfrow = c(1, 3), mar = c(8, 4, 4, 2))
boxplot(log2(original_data + 1), main = "Original Data", las = 2, col = "lightblue")
boxplot(log2(norm_data + 1), main = "nSolver Normalized", las = 2, col = "#CC99FF")
boxplot(log2(final_norm_data + 1), main = "+ Size Factors", las = 2, col = "#FF66B2")


png("boxplots_normalization.png", width = 1800, height = 600, res = 150)

par(mfrow = c(1, 3), mar = c(8, 4, 4, 2))
boxplot(log2(original_data + 1), main = "Original Data", las = 2, col = "lightblue")
boxplot(log2(norm_data + 1), main = "nSolver Normalized", las = 2, col = "#CC99FF")
boxplot(log2(final_norm_data + 1), main = "+ Size Factors", las = 2, col = "#FF66B2")

dev.off()


```

7.4 **Correlation after SF**
```{r correlation after SF correction}

# 1. Definir clases de genes (usando la matriz corregida)
gene_data_sf <- data.frame(
  Gene = rownames(final_norm_data),
  CodeClass = ifelse(startsWith(rownames(final_norm_data), "Endogenous_"), "Endogenous",
           ifelse(startsWith(rownames(final_norm_data), "Negative_"), "Negative",
           ifelse(startsWith(rownames(final_norm_data), "Positive_"), "Positive",
           ifelse(startsWith(rownames(final_norm_data), "Housekeeping_"), "Housekeeping",
                  "Otro")))),
  row.names = rownames(final_norm_data)
)

# Guardar datos corregidos (batch + size factors)
write.csv(final_norm_data, file = "datos_corregidos_sizefactors.csv", row.names = TRUE)



# Función para extraer el identificador corto entre los últimos dos _
extract_sample_id <- function(full_names) {
  # Dividir por _ y tomar el penúltimo elemento
  sapply(strsplit(full_names, "_"), function(x) {
    if(length(x) >= 2) {
      return(x[length(x)-1])
    } else {
      return(full_names)
    }
  })
}

# Modificar la función analyze_gene_class_sf
analyze_gene_class_sf <- function(expr_matrix, gene_annotations, gene_class, title_name) {
  
  # Verificaciones
  if (!"CodeClass" %in% colnames(gene_annotations)) {
    stop("El dataframe gene_annotations debe contener la columna 'CodeClass'")
  }
  
  # 1. Preparación de datos
  counts_totales <- colSums(expr_matrix)
  class_genes <- rownames(gene_annotations)[gene_annotations$CodeClass == gene_class]
  class_expr <- expr_matrix[class_genes, , drop = FALSE]
  
  # Acortar nombres de muestras
  short_names <- extract_sample_id(colnames(class_expr))
  
  # 2. Boxplot de expresión por muestra
  df_box <- as.data.frame(t(class_expr)) %>% 
    tibble::rownames_to_column("Muestra") %>% 
    mutate(MuestraShort = extract_sample_id(Muestra)) %>% 
    pivot_longer(-c(Muestra, MuestraShort), names_to = "Gene", values_to = "Expression")
  
  p_box <- ggplot(df_box, aes(x = MuestraShort, y = Expression, fill = MuestraShort)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Expresión de", title_name, "(Post-Corrección)"),
      x = "Muestra",
      y = "Expresión (log10)"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
          legend.position = "none") +
    scale_fill_manual(values = color_palette)
  
  # 3. Análisis de correlación con counts totales
  corr_data <- data.frame(
    Sample = short_names,
    TotalCounts = counts_totales[colnames(class_expr)],
    t(class_expr)
  ) %>% 
    pivot_longer(
      cols = -c(Sample, TotalCounts),
      names_to = "Gene",
      values_to = "Expression"
    ) %>% 
    group_by(Gene) %>% 
    mutate(
      Correlation = cor(TotalCounts, Expression, method = "spearman"),
      Label = paste0("r = ", round(Correlation, 2))
    ) %>% 
    ungroup()
  
  # Posiciones para etiquetas
label_pos <- corr_data %>%
  group_by(Gene) %>%
  summarise(
    Correlation = dplyr::first(Correlation),
    Label = dplyr::first(Label),
    TotalCounts = max(TotalCounts) * 0.7,
    Expression = quantile(Expression, 0.8)
  )

  
  p_cor <- ggplot(corr_data, aes(x = TotalCounts, y = Expression, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_pos,
      aes(label = Label),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_log10() +
    scale_y_log10() +
    labs(
      title = paste("Correlación:", title_name, "vs. Counts Totales"),
      subtitle = "Post-corrección",
      x = "Counts Totales (log10)",
      y = "Expresión (log10)",
      color = title_name
    ) +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
  
  # Tabla de correlaciones
  cor_table <- corr_data %>% 
    distinct(Gene, Correlation) %>% 
    arrange(desc(abs(Correlation))) %>% 
    mutate(Correlation = round(Correlation, 3))
  
  # Resultados
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table,
    expression_matrix = class_expr
  )
}


# Ejecutar análisis para cada clase (con correlación)
results_sf <- list(
  positive = analyze_gene_class_sf(
    expr_matrix = final_norm_data,
    gene_annotations = gene_data_sf,
    gene_class = "Positive",
    title_name = "Controles Positivos"
  ),
  housekeeping = analyze_gene_class_sf(
    expr_matrix = final_norm_data,
    gene_annotations = gene_data_sf,
    gene_class = "Housekeeping",
    title_name = "Genes Housekeeping"
  ),
  negative = analyze_gene_class_sf(
    expr_matrix = final_norm_data,
    gene_annotations = gene_data_sf,
    gene_class = "Negative",
    title_name = "Controles Negativos"
  )
)

# Mostrar tablas de correlación en consola
cat("\n=== Tabla de correlación para Controles Positivos ===\n")
print(results_sf$positive$correlation_table)

cat("\n=== Tabla de correlación para Controles Negativos ===\n")
print(results_sf$negative$correlation_table)

cat("\n=== Tabla de correlación para Genes Housekeeping ===\n")
print(results_sf$housekeeping$correlation_table)

# Cargar paquetes necesarios
library(gridExtra)
library(grid)
library(ggplot2)

# Crear objeto tabla gráfica
tabla_grafica <- tableGrob(results_sf$housekeeping$correlation_table)

# Guardar como PNG
png("tabla_correlacion_housekeeping.png", width = 800, height = 600)
grid.draw(tabla_grafica)
dev.off()


# Exportar gráficos y tablas (el mismo código anterior)


# 4. Exportar gráficos adicionales de correlación
# a) Controles positivos
ggsave(
  filename = "Results_PostSizeFactors/correlation_positive_controls.png",
  plot = results_sf$positive$correlation_plot,
  width = 8, height = 6, dpi = 300
)

ggsave(
  filename = "Results_PostSizeFactors/correlation_positive_controls.pdf",
  plot = results_sf$positive$correlation_plot,
  width = 8, height = 6
)

# b) Controles negativos
ggsave(
  filename = "Results_PostSizeFactors/correlation_negative_controls.png",
  plot = results_sf$negative$correlation_plot,
  width = 8, height = 6, dpi = 300
)

ggsave(
  filename = "Results_PostSizeFactors/correlation_negative_controls.pdf",
  plot = results_sf$negative$correlation_plot,
  width = 8, height = 6
)

# c) Genes housekeeping
ggsave(
  filename = "Results_PostSizeFactors/correlation_housekeeping_genes.png",
  plot = results_sf$housekeeping$correlation_plot,
  width = 10, height = 6, dpi = 300
)

ggsave(
  filename = "Results_PostSizeFactors/correlation_housekeeping_genes.pdf",
  plot = results_sf$housekeeping$correlation_plot,
  width = 10, height = 6
)

# Crear carpeta si no existe
if (!dir.exists("Results_PostSizeFactors")) dir.create("Results_PostSizeFactors")

# a) Controles positivos
ggsave(
  filename = "Results_PostSizeFactors/boxplot_positive_controls.png",
  plot = results_sf$positive$boxplot,
  width = 10, height = 6, dpi = 300
)

ggsave(
  filename = "Results_PostSizeFactors/boxplot_positive_controls.pdf",
  plot = results_sf$positive$boxplot,
  width = 10, height = 6
)

# b) Controles negativos
ggsave(
  filename = "Results_PostSizeFactors/boxplot_negative_controls.png",
  plot = results_sf$negative$boxplot,
  width = 10, height = 6, dpi = 300
)

ggsave(
  filename = "Results_PostSizeFactors/boxplot_negative_controls.pdf",
  plot = results_sf$negative$boxplot,
  width = 10, height = 6
)

# c) Genes housekeeping
ggsave(
  filename = "Results_PostSizeFactors/boxplot_housekeeping_genes.png",
  plot = results_sf$housekeeping$boxplot,
  width = 10, height = 6, dpi = 300
)


# 5. Exportar tablas de correlación
write.csv(
  results_sf$positive$correlation_table,
  file = "Results_PostSizeFactors/correlation_table_positive_controls.csv",
  row.names = FALSE
)

write.csv(
  results_sf$negative$correlation_table,
  file = "Results_PostSizeFactors/correlation_table_negative_controls.csv",
  row.names = FALSE
)

write.csv(
  results_sf$housekeeping$correlation_table,
  file = "Results_PostSizeFactors/correlation_table_housekeeping_genes.csv",
  row.names = FALSE
)

```


8. **Batch Effect**
```{r Batch Effect}
pacman::p_load(
  ggplot2, 
  ggrepel,
  pheatmap,
  RColorBrewer,
  limma,
  lme4,
  variancePartition,
  dplyr,
  reshape2,
  NanoStringNCTools,
  gridExtra
)

# Configurar directorio de salida
output_dir <- "batch_effect_analysis"
if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}

# ----------------------------
# 2. Preparación de metadatos
# ----------------------------

cat("Preparando metadatos...\n")

# Verificar datos de entrada
if (!exists("final_norm_data")) {
  stop("Error: No se encontró el objeto 'final_norm_data'.")
}

# Extraer matriz de expresión
expr_matrix <- if (is(final_norm_data, "ExpressionSet")) {
  Biobase::exprs(final_norm_data)
} else {
  as.matrix(final_norm_data)
}

# Limpiar nombres de muestras
clean_sample_names <- gsub("^_GEM_", "", colnames(expr_matrix))

# Crear metadatos
metadata <- data.frame(
  SampleID = clean_sample_names,
  OriginalID = colnames(expr_matrix),
  Batch = factor(case_when(
    grepl("RunA", clean_sample_names) ~ "RunA",
    grepl("RunB", clean_sample_names) ~ "RunB",
    grepl("RunC", clean_sample_names) ~ "RunC",
    TRUE ~ NA_character_
  )),
  Type = factor(ifelse(grepl("Stand", clean_sample_names), "Standard", "Sample")),
  row.names = colnames(expr_matrix),
  stringsAsFactors = FALSE
)

# Guardar metadatos
write.csv(metadata, file.path(output_dir, "metadata.csv"))

# ----------------------------
# 3. Análisis exploratorio
# ----------------------------

cat("\nRealizando análisis exploratorio...\n")

# Configuración visual
batch_colors <- c(RunA = "#FF66B2",  # Rosa
                 RunB = "#CC99FF",    # Lila
                 RunC = "#66B2FF")    # Azul claro

## 3.1 PCA ##
sample_idx <- metadata$Type == "Sample"
expr_samples <- expr_matrix[, sample_idx]
batch_samples <- metadata$Batch[sample_idx]

pca_result <- prcomp(t(expr_samples), scale. = TRUE)
pca_vars <- round(100 * pca_result$sdev^2 / sum(pca_result$sdev^2), 1)

pca_data <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  Batch = batch_samples,
  Sample = metadata$SampleID[sample_idx]
)

pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = Batch)) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(values = batch_colors) +
  labs(
    title = "Análisis PCA por lote",
    x = paste0("PC1 (", pca_vars[1], "%)"),
    y = paste0("PC2 (", pca_vars[2], "%)")
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave(file.path(output_dir, "pca_plot.png"), pca_plot, width = 10, height = 8)

## 3.2 Heatmap de correlación ##
gene_vars <- rowVars(expr_samples)
expr_filtered <- expr_samples[gene_vars > quantile(gene_vars, 0.75), ]

cor_matrix <- cor(expr_filtered, use = "complete.obs")
rownames(cor_matrix) <- colnames(cor_matrix) <- metadata$SampleID[sample_idx]

annotation_df <- data.frame(Batch = batch_samples)
rownames(annotation_df) <- colnames(expr_filtered)

heatmap_plot <- pheatmap(
  cor_matrix,
  annotation_col = annotation_df,
  annotation_colors = list(Batch = batch_colors),
  color = colorRampPalette(rev(brewer.pal(9, "RdBu")))(100),
  main = "Matriz de correlación entre muestras",
  show_rownames = TRUE,
  show_colnames = FALSE,
  fontsize_row = 6,
  fontsize_col = 6,
  filename = file.path(output_dir, "correlation_heatmap.png")
)

## 3.3 Boxplots de expresión ##
set.seed(123)
selected_genes <- sample(1:nrow(expr_samples), min(50, nrow(expr_samples)))
expr_melted <- reshape2::melt(expr_samples[selected_genes, ])
expr_melted$Batch <- rep(batch_samples, each = length(selected_genes))

boxplot <- ggplot(expr_melted, aes(x = Batch, y = value, fill = Batch)) +
  geom_boxplot(outlier.size = 0.5) +
  scale_fill_manual(values = batch_colors) +
  labs(
    title = "Distribución de expresión por lote",
    subtitle = paste(length(selected_genes), "genes seleccionados aleatoriamente"),
    y = "Nivel de expresión (normalizado)"
  ) +
  theme_minimal() +
  coord_cartesian(ylim = quantile(expr_melted$value, c(0.05, 0.95)))

ggsave(file.path(output_dir, "expression_boxplots.png"), boxplot, width = 8, height = 6)

# ----------------------------
# 4. Análisis estadístico
# ----------------------------

cat("\nRealizando análisis estadístico...\n")

## 4.1 Análisis con limma ##
design <- model.matrix(~ 0 + batch_samples)
colnames(design) <- levels(batch_samples)

fit <- lmFit(expr_samples, design) |> eBayes()
batch_results <- topTable(fit, number = Inf, sort.by = "none")

pval_plot <- ggplot(batch_results, aes(x = P.Value)) +
  geom_histogram(bins = 30, fill = "steelblue", boundary = 0) +
  labs(
    title = "Distribución de p-valores para efecto de lote",
    x = "p-valor",
    y = "Frecuencia"
  ) +
  theme_minimal()

ggsave(file.path(output_dir, "pvalue_distribution.png"), pval_plot, width = 8, height = 6)

## 4.2 Análisis de componentes de varianza ##
var_part <- fitExtractVarPartModel(
  expr_samples[1:min(100, nrow(expr_samples)), ],
  ~ (1|Batch),
  metadata[sample_idx, ]
)

variance_summary <- data.frame(
  Source = c("Batch", "Residual"),
  Variance = c(mean(var_part$Batch), mean(var_part$Residual))
) |>
  mutate(Percentage = round(100 * Variance / sum(Variance), 1))

print(batch_results)

write.csv(variance_summary, file.path(output_dir, "variance_components.csv"))
```

9. **KDE Plot después de normalización y estadarización**
```{r KDE Plot: After batch}

## 1. Preparar los datos corregidos en formato largo
exprs_long_corrected <- final_norm_data %>% 
  as.data.frame() %>% 
  tibble::rownames_to_column("Gene") %>% 
  pivot_longer(-Gene, names_to = "Sample", values_to = "Expression")

## 2. Definir muestras a incluir (ajusta con tus muestras reales)
included_samples <- c("20220215_IO360melRunC_GEM36_06.RCC", 
                     "20210316_IO360melRunA_GEM4_03.RCC", 
                     "20210316_IO360melRunA_GEM17_09.RCC", 
                     "20210316_IO360melRunA_GEM12_06.RCC")

## 3. Filtrar los datos
exprs_included <- exprs_long_corrected %>% 
  filter(Sample %in% included_samples)

all_samples <- exprs_long_corrected


# Versión mejorada con más opciones visuales
plot_included <- ggplot(exprs_included, aes(x = Expression, color = Sample)) +
  geom_density(linewidth = 1, alpha = 0.7) +
  scale_x_continuous(limits = c(-500, 1500)) +
  geom_rug(alpha = 0.3) +  # Muestra puntos individuales  
  labs(title = "Muestras problemáticas (post-SFactors)",
       x = "Expresión normalizada",
       y = "Densidad") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "right",
        plot.title = element_text(face = "bold"))


plot_excluded <- ggplot(all_samples, aes(x = Expression, color = Sample)) +
  geom_density(linewidth = 1, alpha = 0.7) +
  scale_x_continuous(limits = c(-500, 1500)) +
  geom_rug(alpha = 0.3) +  # Muestra puntos individuales
  labs(title = "Todas las muestras (post-SFactors)",
       x = "Expresión normalizada",
       y = "Densidad") +
  theme_minimal(base_size = 12) +
    theme(legend.position = "none",
        plot.title = element_text(face = "bold"))

# Combinar con diseño vertical
combined_plot <- plot_included / plot_excluded +
  plot_annotation(
    title = "Control de Calidad Post-Corrección",
    subtitle = "Distribución de expresión génica normalizada",
    caption = "Datos normalizados por SizeFactors"
  )

print(combined_plot)

ggsave("KDE_post_sf.png", 
       plot = combined_plot,
       width = 15, 
       height = 10,
       dpi = 300)
```



**Análisis de outliers**
```{r}
# Verificar datos de entrada
if (!exists("final_norm_data")) {
  stop("Error: No se encontró el objeto 'final_norm_data'.")
}

# Extraer matriz de expresión
expr_matrix <- if (is(final_norm_data, "ExpressionSet")) {
  Biobase::exprs(final_norm_data)
} else {
  as.matrix(final_norm_data)
}

# Limpiar nombres de muestras (se mantiene para referencia)
clean_sample_names <- gsub("^_GEM_", "", colnames(expr_matrix)) 

# Calcular matriz de correlación Spearman
cor_matrix <- cor(expr_matrix, method = "spearman")
rownames(cor_matrix) <- clean_sample_names
colnames(cor_matrix) <- clean_sample_names

# 1. DEFINIR THRESHOLD DE OUTLIERS (ajustable)
cor_threshold <- 0.6 #(típico: 0.6-0.8)

# 2. Análisis de clusters
hc <- hclust(as.dist(1-cor_matrix))
num_clusters <- 3
clusters <- cutree(hc, k = num_clusters)

# 3. Identificación de outliers
mean_cor <- apply(cor_matrix, 1, mean)
outlier_flag <- ifelse(mean_cor < cor_threshold, "Outlier", "Normal")

# 4. Preparar anotaciones
annotation_df <- data.frame(
  Mean_Correlation = mean_cor,
  Status = outlier_flag,
  Cluster = as.factor(clusters))
rownames(annotation_df) <- clean_sample_names

# 5. Visualización sin nombres de muestra
library(pheatmap)
library(RColorBrewer)

heatmap_colors <- colorRampPalette(brewer.pal(9, "YlOrRd"))(100)

# === HEATMAP DE CORRELACIÓN ===
png("Heatmap_Correlacion_Spearman.png", width = 1200, height = 1000)
pheatmap(cor_matrix,
         color = heatmap_colors,
         clustering_distance_rows = as.dist(1 - cor_matrix),
         clustering_distance_cols = as.dist(1 - cor_matrix),
         cutree_rows = num_clusters,
         cutree_cols = num_clusters,
         annotation_row = annotation_df,
         annotation_col = annotation_df,
         show_rownames = TRUE,
         show_colnames = FALSE,
         fontsize = 8,
         main = paste("Correlación Spearman | Outliers (cor <", cor_threshold, ")"))
dev.off()

# === HISTOGRAMA DE CORRELACIONES PROMEDIO ===
png("Histograma_Correlaciones_Promedio.png", width = 1000, height = 800)
hist(mean_cor, breaks = 30, col = "lightblue",
     main = "Distribución de Correlaciones Promedio",
     xlab = "Correlación Promedio",
     ylab = "Frecuencia")
abline(v = cor_threshold, col = "red", lty = 2)
legend("topright", legend = paste("Threshold =", cor_threshold), col = "red", lty = 2)
dev.off()




```


