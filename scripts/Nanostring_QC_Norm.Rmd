---
title: "Análisis Completo de Datos NanoString IO 360"
author: "xxx"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
    number_sections: true
    theme: cosmo
    highlight: tango
    code_folding: show
    df_print: paged
    self_contained: true
lang: es
---

Este informe detalla la Normalización y control de calidad de un ensayo de Nanostring Immune-Oncology 360. Se ha usado la herramienta de BioConductor https://bioconductor.org/packages/release/bioc/html/NanoStringNCTools.html para realizar las normalizaciónes (nCounter y SizeFactors) y el control de calidad.

0. **Instalación y carga de paquetes**:
    
    ```{r Packages}
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }

    required_packages <- c("NanoStringNCTools", "ggplot2", "ggiraph", "dplyr", "tibble", "readr", "tidyr", "RColorBrewer", "patchwork", "gridExtra", "GeomxTools", "pheatmap", "corrplot", "sva", "Biobase", "cluster", "merTools", "lme4", "reshape2", "limma", "ggrepel", "DESeq2", "here")
    for (pkg in required_packages) {
      if (!requireNamespace(pkg, quietly = TRUE)) {
        BiocManager::install(pkg)
      }
      library(pkg, character.only = TRUE)
    }
    ```

 ```{r rutas y archivos}
# =========================================
# 1. Definir rutas de forma genérica
# =========================================
# Carpeta raíz del proyecto
datadir <- here("data", "Rawdata")      # RCC y CSV originales
results_dir <- here("results")
plots_dir <- file.path(results_dir, "plots")
tables_dir <- file.path(results_dir, "tables")

# Crear carpetas si no existen
dir.create(results_dir, showWarnings = FALSE)
dir.create(plots_dir, showWarnings = FALSE)
dir.create(tables_dir, showWarnings = FALSE)


# =========================================
# 2. Archivos a usar
# =========================================
rlf_file <- file.path(datadir, "NS_IO_360_v1.0.rlf")
sample_annotation_file <- file.path(datadir, "NS_IO_360_v1.03runs_.csv")


# =========================================
# 3. Leer y procesar sample annotation
# =========================================
read_sample_annotation <- function(file_path) {
  sample_data <- read.csv(file_path, check.names = FALSE, stringsAsFactors = FALSE, header = FALSE)
  sample_data_t <- as.data.frame(t(sample_data), stringsAsFactors = FALSE)
  colnames(sample_data_t) <- sample_data_t[1, ]
  sample_data_t <- sample_data_t[-1, ]
  
  if (all(c("File Name", "Sample ID") %in% colnames(sample_data_t))) {
    sample_data_t <- sample_data_t[, c("File Name", "Sample ID")]
  } else {
    stop("Las columnas 'File Name' y/o 'Sample ID' no se encuentran en el archivo CSV.")
  }
  
  sample_data_t <- sample_data_t[!is.na(sample_data_t$`File Name`) & sample_data_t$`File Name` != "", ]
  sample_data_t <- sample_data_t[!is.na(sample_data_t$`Sample ID`) & sample_data_t$`Sample ID` != "", ]
  return(sample_data_t)
}

sample_data_t <- read_sample_annotation(sample_annotation_file)


# =========================================
# 4. Cargar archivos RCC
# =========================================
rcc_files <- list.files(datadir, pattern = "\\.RCC$", full.names = TRUE)
rcc_names <- basename(rcc_files)
missing_files <- setdiff(sample_data_t$`File Name`, rcc_names)
if(length(missing_files) > 0){
  warning("Faltan archivos RCC: ", paste(missing_files, collapse = ", "))
} else {
  message("Todos los archivos RCC están presentes.")
}
    ```



    ```{r NanoStringSet object}

# =========================================
# 5. Crear NanoStringSet
# =========================================
temp_annotation_file <- tempfile(fileext = ".csv")
write.csv(sample_data_t, temp_annotation_file, row.names = FALSE)

nanoStringData <- readNanoStringRccSet(
  rcc_files,
  rlfFile = rlf_file,
  phenoDataFile = temp_annotation_file,
  phenoDataRccColName = "File Name"
)
class(nanoStringData)
isS4(nanoStringData)
is(nanoStringData, "ExpressionSet")
nanoStringData

## nCounter Data Resumen
# summarize log2 counts for each feature
head(summary(nanoStringData, MARGIN = 1), 2)

# summarize log2 counts for each sample
head(summary(nanoStringData, MARGIN = 2), 2)


##Subsetting de los objetos de NanoStringRCCSet
# check the number of samples in the dataset
length(sampleNames(nanoStringData))

# check the dimension of the expression matrix
dim(exprs(nanoStringData))

# housekeepingSubset() only selects housekeeper genes
with(housekeepingSubset(nanoStringData), table(CodeClass))

# negativeControlSubset() only selects negative probes
with(negativeControlSubset(nanoStringData), table(CodeClass))

# positiveControlSubset() only selects positive probes
with(positiveControlSubset(nanoStringData), table(CodeClass))

# controlSubset() selects all control probes
with(controlSubset(nanoStringData), table(CodeClass))

# nonControlSubset() selects all non-control probes
with(nonControlSubset(nanoStringData), table(CodeClass))

```


```{r Quality Control}
# =========================================
# 6. Control de Calidad
# =========================================
# negativeControlSubset() only selects negative probes
with(negativeControlSubset(nanoStringData), table(CodeClass))
    
    neg_set <- negativeControlSubset(nanoStringData)
class(neg_set)

# Use the setSeqQCFlags function to set Sequencing QC Flags to your dataset. The default cutoff are displayed in the function. 
nanoStringData <- setQCFlags(nanoStringData,
                       qcCutoffs = list(Housekeeper = c(failingCutoff = 32, passingCutoff = 100), 
                                        Imaging = c(fovCutoff = 0.75), 
                                        BindingDensity = c(minimumBD = 0.1, maximumBD = 2.25, maximumBDSprint = 1.8), 
                                        ERCCLinearity = c(correlationValue = 0.95), 
                                        ERCCLoD = c(standardDeviations = 2)))

# show the last 6 column names in the data
tail(svarLabels(nanoStringData))

# show the first 2 rows of the QC Flags results
protocolData(nanoStringData)
head(protocolData(nanoStringData)[["QCFlags"]])

# show the first 2 rows of the QC Borderline Flags results
head(protocolData(nanoStringData)[["QCBorderlineFlags"]])


girafe(ggobj = autoplot(nanoStringData, type = "housekeep-geom"))



girafe(ggobj = autoplot(nanoStringData, type = "lane-bindingDensity"))


girafe(ggobj = autoplot(nanoStringData, type = "lane-fov"))


girafe(ggobj = autoplot(nanoStringData, type = "ercc-linearity"))


girafe(ggobj = autoplot(nanoStringData, type = "ercc-lod"))

girafe(ggobj = autoplot(nanoStringData, "boxplot-feature", index = featureNames(nanoStringData)[3], elt = "exprs"))


#crear tabla
# Extraer los nombres de las muestras
sample_names <- sampleNames(nanoStringData)

# Extraer las QCFlags y QCBorderlineFlags
qc_flags <- protocolData(nanoStringData)[["QCFlags"]]
qc_borderline_flags <- protocolData(nanoStringData)[["QCBorderlineFlags"]]

# Combinar los nombres de las muestras con las flags en un data frame
flags_table <- data.frame(
  SampleName = sample_names,
  QCFlags = qc_flags,
  QCBorderlineFlags = qc_borderline_flags
)

# Mostrar las primeras filas de la tabla
head(flags_table)


```


```{r Gene counts distribution}
# =========================================
# 7. Exploración de los datos crudos
# =========================================

## 7.1 Grafico distribución genes por paciente
library(tidyverse)

# Convertir datos normalizados a data.frame
data_df <- as.data.frame(nanoStringData)

# Identificar columnas de expresión (todas las que empiezan con 'Endogenous_')
expr_cols <- grep("^Endogenous_", colnames(data_df), value = TRUE)

# Transformar a formato largo
data_long <- pivot_longer(data_df,
                          cols = all_of(expr_cols),
                          names_to = "Gene",
                          values_to = "Expression")

# Generar paleta de colores automática según número de muestras
n_samples <- length(unique(data_long$Sample.ID))
color_palette <- colorRampPalette(c("#08306B", "#4292C6", "#9ECAE1",
                                    "#54278F", "#9E9AC8", "#DADAEB",
                                    "#7A0177", "#C51B8A", "#FCC5C0"))(n_samples)

# Boxplot
expression_plot <- ggplot(data_long, aes(x = Sample.ID, y = Expression, fill = Sample.ID)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.8) +
  scale_fill_manual(values = color_palette) +
  theme_minimal() +
  labs(title = "Distribución de expresión",
       x = "Muestras", y = "Expresión") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        legend.position = "none")

# Mostrar gráfico
print(expression_plot)

# Exportar
ggsave("boxplot_expression.png", expression_plot, width = 14, height = 7, units = "in", dpi = 300)


## 7.2  Grafico counts totales por muestra
# Asegurarte de que color_palette tiene suficientes colores
blues <- colorRampPalette(c("#08306B", "#4292C6", "#9ECAE1"))(12)
purples <- colorRampPalette(c("#54278F", "#9E9AC8", "#DADAEB"))(12)
pinks <- colorRampPalette(c("#7A0177", "#C51B8A", "#FCC5C0"))(11)

color_palette <- c(blues, purples, pinks)

# Calcular counts totales por muestra
total_counts_df <- data_long %>%
  group_by(Sample.ID) %>%
  summarise(TotalCounts = sum(Expression, na.rm = TRUE)) %>%
  ungroup()

# Barplot
total_counts_plot <- ggplot(total_counts_df, aes(x = Sample.ID, y = TotalCounts, fill = Sample.ID)) +
  geom_bar(stat = "identity", alpha = 0.8) +
  scale_fill_manual(values = color_palette) +
  theme_minimal() +
  labs(title = "Counts totales por muestra", x = "Muestras", y = "Counts totales") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        legend.position = "none") +
  geom_text(aes(label = round(TotalCounts)), vjust = -0.5, size = 3)

print(total_counts_plot)

ggsave("total_counts.png", total_counts_plot, width = 14, height = 7, units = "in", dpi = 300)


## 7.7 0 per sample
# Obtener matriz de counts
count_matrix <- exprs(nanoStringData)

# Data frame de genes con 0 counts
zero_counts <- as.data.frame(count_matrix == 0)
names(zero_counts) <- sampleNames(nanoStringData)
rownames(zero_counts) <- featureNames(nanoStringData)

# Resumen: número de genes con 0 counts por muestra
zero_counts_summary <- colSums(zero_counts)
write.csv(data.frame(Sample = names(zero_counts_summary),
                     Genes_with_zero_counts = zero_counts_summary),
          file = "zero_counts_summary.csv", row.names = FALSE)

# Matriz detallada de genes con 0 counts en al menos una muestra
genes_with_zero <- zero_counts[rowSums(zero_counts) > 0, ]
genes_with_zero <- genes_with_zero[order(rowSums(genes_with_zero), decreasing = TRUE), ]
write.csv(genes_with_zero, file = "genes_with_zero_counts.csv")

```


```{r KDE Plot}
# =========================================
# 8. KDE Plot de distribución por muestra
# =========================================
exprs_df <- as.data.frame(exprs(nanoStringData))
exprs_long <- gather(exprs_df, key = "Sample", value = "Expression", 1:ncol(exprs_df))
exprs_long$Gene <- rep(rownames(exprs(nanoStringData)), each = ncol(exprs(nanoStringData)))

plot_densidad <- ggplot(exprs_long, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) +
  scale_x_continuous(limits = c(-500, 3000)) +
  theme_minimal() +
  labs(title = "Distribución de expresión por muestra", x = "Expresión (counts)", y = "Densidad") +
  theme(legend.position = "none")

ggsave(file.path(plots_dir, "densidad_expresion_genes.png"), plot_densidad, width = 10, height = 6, dpi = 300)


## 8.1 Muestras atípicas
# Calcular métricas de distribución
dist_metrics <- exprs_long %>%
  group_by(Sample) %>%
  summarise(
    Mediana = median(Expression),
    MAD = mad(Expression),
    Distancia_KS = ks.test(Expression, ecdf(exprs_long$Expression))$statistic
  ) %>%
  arrange(desc(Distancia_KS))

# Top 8% muestras atípicas
umbral <- quantile(dist_metrics$Distancia_KS, 0.92)
muestras_atipicas <- dist_metrics %>% filter(Distancia_KS > umbral) %>% pull(Sample)

# Colores automáticos (ajustar al número de muestras atípicas)
colores_atipicas <- RColorBrewer::brewer.pal(n = max(3, length(muestras_atipicas)), name = "Set2")

ggplot(exprs_long, aes(x = Expression)) +
  geom_density(data = subset(exprs_long, !(Sample %in% muestras_atipicas)), 
               color = "gray80", alpha = 0.2) +
  geom_density(data = subset(exprs_long, Sample %in% muestras_atipicas),
               aes(color = Sample, fill = Sample), alpha = 0.3, linewidth = 1.2) +
  labs(title = paste("Muestras atípicas:", length(muestras_atipicas)),
       subtitle = "Basado en distancia KS",
       x = "Expresión (counts)", y = "Densidad") +
  scale_color_manual(values = colores_atipicas) +
  scale_fill_manual(values = colores_atipicas) +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave("muestras_atipicas_colores.png", width = 10, height = 6, dpi = 300, bg = "white")


## 8.2 Muestras seleccionadas(problema/flags) vs buenas
# Seleccionar las muestras que deseas incluir
included_samples <- c("20220215_IO360melRunC_GEM36_06.RCC", 
                      "20210316_IO360melRunA_GEM4_03.RCC", 
                      "20210316_IO360melRunA_GEM17_09.RCC", 
                      "20210316_IO360melRunA_GEM12_06.RCC")

exprs_long_included <- exprs_long %>% filter(Sample %in% included_samples)
exprs_long_excluded <- exprs_long %>% filter(!Sample %in% included_samples)

library(patchwork)

plot_included <- ggplot(exprs_long_included, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) + theme_minimal() +
  labs(title = "Muestras problemáticas", x = "Expresión", y = "Densidad") +
  theme(legend.position = "none")

plot_excluded <- ggplot(exprs_long_excluded, aes(x = Expression, color = Sample)) +
  geom_density(alpha = 0.5) + theme_minimal() +
  labs(title = "Muestras normales", x = "Expresión", y = "Densidad") +
  theme(legend.position = "none")

combined_plots <- plot_included + plot_excluded +
  plot_annotation(title = "Comparación de distribuciones", subtitle = "Control de calidad")

ggsave("comparacion_muestras_incluidas_excluidas.png", combined_plots, width = 14, height = 6, dpi = 300, bg = "white")
```


```{r Correlation plot}
# =========================================
# 9. Correlation plot before normalization
# =========================================
n_samples <- ncol(exprs(nanoStringData))
color_palette <- RColorBrewer::brewer.pal(min(8, n_samples), "Set2")

analyze_gene_class <- function(nanoStringData, gene_class, title_name) {
  # Extract data
  counts_totales <- colSums(exprs(nanoStringData))
  
  # Determine the prefix based on gene class
  prefix <- switch(gene_class,
                  "Positive" = "POS_",
                  "Negative" = "NEG_",
                  "Housekeeping" = "Housekeeping_",
                  "")
  
  class_expr <- exprs(nanoStringData)[fData(nanoStringData)$CodeClass == gene_class, ]
  
  # Modify sample names to keep only _GEM_ part
  modified_sample_names <- sapply(colnames(class_expr), function(x) {
    parts <- unlist(strsplit(x, "_"))
    gem_part <- parts[grep("GEM", parts)]
    if(length(gem_part) > 0) gem_part else x
  })
  
  colnames(class_expr) <- modified_sample_names
  
  # Boxplot of distribution across samples
  df_box <- as.data.frame(t(class_expr))
  df_box$Muestra <- rownames(df_box)
  df_long_box <- gather(df_box, key = "Gene", value = "Count", -Muestra)
  
  p_box <- ggplot(df_long_box, aes(x = Muestra, y = Count, fill = Muestra)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Distribución de", title_name, "(Datos Crudos)"),
      subtitle = "Distribución entre muestras",
      x = "Muestra",
      y = "Counts (log10)"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
      legend.position = "none"
    ) +
    scale_fill_manual(values = color_palette)
  
  # Modify gene names to remove class prefix and anything after NM if present
  modified_gene_names <- sapply(rownames(class_expr), function(x) {
    # Remove prefix
    x_no_prefix <- sub(paste0("^", prefix), "", x)
    # Remove _NM suffix if present
    sub("_NM.*$", "", x_no_prefix)
  })
  
  rownames(class_expr) <- modified_gene_names
  
  # Correlation plot
  df_cor <- data.frame(
    Muestra = colnames(class_expr),
    Counts_Totales = counts_totales,
    t(class_expr)
  ) %>% 
    pivot_longer(
      cols = -c(Muestra, Counts_Totales),
      names_to = "Gene",
      values_to = "Expresion"
    ) %>% 
    group_by(Gene) %>% 
    mutate(
      Correlacion = cor(Counts_Totales, Expresion, method = "spearman"),
      Etiqueta_r = paste0("r = ", round(Correlacion, 2))
    ) %>% 
    ungroup()
  
  # Calculate positions for r labels
  label_data <- df_cor %>%
    group_by(Gene) %>%
    summarize(
      Correlacion = dplyr::first(Correlacion),
      Etiqueta_r = dplyr::first(Etiqueta_r),
      Counts_Totales = max(Counts_Totales) * 0.7,
      Expresion = max(Expresion) * (1 - 0.1 * cur_group_id())
)

  
  p_cor <- ggplot(df_cor, aes(x = Counts_Totales, y = Expresion, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_data,
      aes(x = Counts_Totales, y = Expresion, label = Etiqueta_r),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_continuous(labels = scales::comma, trans = "log10") +
    scale_y_continuous(trans = "log10") +
    labs(
      title = paste("Expresión de", title_name, "vs. Counts Totales"),
      subtitle = "Relación con el total de counts por muestra",
      x = "Counts Totales (log10)",
      y = paste("Expresión de", title_name, "(log10)"),
      color = title_name
    ) +
    theme_bw() +
    theme(
      legend.position = "right",
      panel.grid.minor = element_blank()
    ) +
    scale_fill_manual(values = color_palette)
  
  # Correlation table
  cor_table <- df_cor %>% 
    distinct(Gene, Correlacion) %>% 
    arrange(desc(Correlacion))
  
  # Return results
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table
  )
}


# Analyze all three gene classes with correct prefixes
positive_results <- analyze_gene_class(nanoStringData, "Positive", "Controles Positivos")
housekeeping_results <- analyze_gene_class(nanoStringData, "Housekeeping", "Genes Housekeeping")
negative_results <- analyze_gene_class(nanoStringData, "Negative", "Controles Negativos")

# Display all plots
positive_results$boxplot
positive_results$correlation_plot
print(positive_results$correlation_table)

housekeeping_results$boxplot
housekeeping_results$correlation_plot
print(housekeeping_results$correlation_table)

negative_results$boxplot
negative_results$correlation_plot
print(negative_results$correlation_table)

# Crear un directorio para los resultados si no existe
if(!dir.exists("QC_Results")) {
  dir.create("QC_Results")
}

pdf(file.path("QC_Results", "All_QC_Plots.pdf"), width = 10, height = 8)
print(positive_results$boxplot)
print(positive_results$correlation_plot)
print(housekeeping_results$boxplot)
print(housekeeping_results$correlation_plot)
print(negative_results$boxplot)
print(negative_results$correlation_plot)
dev.off()

```



```{r Normalization}
# =========================================
# 10. Normalización y análisis post-normalización
# =========================================
library(here)
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(gridExtra)

# =========================================
# 10.0 Crear carpetas de resultados
# =========================================
results_dir <- here("results")
sf_dir <- here(results_dir, "PostSizeFactors")
if(!dir.exists(results_dir)) dir.create(results_dir)
if(!dir.exists(sf_dir)) dir.create(sf_dir)

# =========================================
# 10.1 Normalización nSolver
# =========================================
nanoStringData_norm <- normalize(
  nanoStringData,
  type = "nSolver",
  fromELT = "exprs",
  toELT = "exprs_norm",
  background = "mean.2sd",
  normTo = "housekeeping.geo.mean",
  take.log = FALSE,
  return.matrix.of.endogenous.probes = FALSE,
  keep.other = TRUE
)

# Extraer matriz de expresión normalizada
exprs_matrix <- assay(nanoStringData_norm, "exprs_norm")

# =========================================
# 10.2 Función de análisis por clase de genes
# =========================================
analyze_gene_class <- function(nanoStringData_obj, gene_class, title_name, color_palette) {
  counts_totales <- colSums(exprs(nanoStringData_obj))
  class_expr <- exprs(nanoStringData_obj)[fData(nanoStringData_obj)$CodeClass == gene_class, ]
  
  # Acortar nombres de muestras (_GEM_ parte)
  modified_sample_names <- sapply(colnames(class_expr), function(x) {
    parts <- unlist(strsplit(x, "_"))
    gem_part <- parts[grep("GEM", parts)]
    if(length(gem_part) > 0) gem_part else x
  })
  colnames(class_expr) <- modified_sample_names
  
  # Boxplot
  df_box <- as.data.frame(t(class_expr))
  df_box$Muestra <- rownames(df_box)
  df_long_box <- gather(df_box, key = "Gene", value = "Count", -Muestra)
  
  p_box <- ggplot(df_long_box, aes(x = Muestra, y = Count, fill = Muestra)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Distribución de", title_name, "(Datos Normalizados)"),
      subtitle = "Distribución entre muestras",
      x = "Muestra",
      y = "Counts (log10)"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
          legend.position = "none") +
    scale_fill_manual(values = color_palette)

  
  # Modify gene names to remove class prefix and anything after NM if present
  modified_gene_names <- sapply(rownames(class_expr), function(x) {
    # Remove prefix
    x_no_prefix <- sub(paste0("^", prefix), "", x)
    # Remove _NM suffix if present
    sub("_NM.*$", "", x_no_prefix)
  })
  
  rownames(class_expr) <- modified_gene_names
  
  # Correlation plot
 # Correlation plot
  df_cor <- data.frame(
    Muestra = colnames(class_expr),
    Counts_Totales = counts_totales,
    t(class_expr)
  ) %>% 
    pivot_longer(
      cols = -c(Muestra, Counts_Totales),
      names_to = "Gene",
      values_to = "Expresion"
    ) %>% 
    group_by(Gene) %>% 
    mutate(
      Correlacion = cor(Counts_Totales, Expresion, method = "spearman"),
      Etiqueta_r = paste0("r = ", round(Correlacion, 2))
    ) %>% 
    ungroup()
  
  label_data <- df_cor %>%
    group_by(Gene) %>%
    summarize(
      Correlacion = dplyr::first(Correlacion),
      Etiqueta_r = dplyr::first(Etiqueta_r),
      Counts_Totales = max(Counts_Totales) * 0.7,
      Expresion = max(Expresion) * (1 - 0.1 * cur_group_id())
    )
  
  p_cor <- ggplot(df_cor, aes(x = Counts_Totales, y = Expresion, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_data,
      aes(x = Counts_Totales, y = Expresion, label = Etiqueta_r),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_log10() +
    scale_y_log10() +
    labs(
      title = paste("Expresión de", title_name, "vs. Counts Totales"),
      subtitle = "Post-normalización",
      x = "Counts Totales (log10)",
      y = paste("Expresión de", title_name, "(log10)"),
      color = title_name
    ) +
    theme_bw() +
    theme(panel.grid.minor = element_blank()) +
    scale_fill_manual(values = color_palette)
  
  cor_table <- df_cor %>% distinct(Gene, Correlacion) %>% arrange(desc(abs(Correlacion)))
  
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table
  )
}

# =========================================
# 10.3 Ejecutar análisis para todas las clases
# =========================================
color_palette <- c("#E41A1C","#377EB8","#4DAF4A","#984EA3","#FF7F00","#FFFF33")  # ejemplo

positive_results <- analyze_gene_class(nanoStringData_norm, "Positive", "Controles Positivos", color_palette)
housekeeping_results <- analyze_gene_class(nanoStringData_norm, "Housekeeping", "Genes Housekeeping", color_palette)
negative_results <- analyze_gene_class(nanoStringData_norm, "Negative", "Controles Negativos", color_palette)

# =========================================
# 10.4 Guardar gráficos y tablas de correlación
# =========================================
ggsave(here(sf_dir, "boxplot_positive_controls.png"), positive_results$boxplot, width = 10, height = 6, dpi = 300)
ggsave(here(sf_dir, "correlation_positive_controls.png"), positive_results$correlation_plot, width = 8, height = 6, dpi = 300)

ggsave(here(sf_dir, "boxplot_negative_controls.png"), negative_results$boxplot, width = 10, height = 6, dpi = 300)
ggsave(here(sf_dir, "correlation_negative_controls.png"), negative_results$correlation_plot, width = 8, height = 6, dpi = 300)

ggsave(here(sf_dir, "boxplot_housekeeping_genes.png"), housekeeping_results$boxplot, width = 10, height = 6, dpi = 300)
ggsave(here(sf_dir, "correlation_housekeeping_genes.png"), housekeeping_results$correlation_plot, width = 10, height = 6, dpi = 300)

write.csv(positive_results$correlation_table, here(sf_dir, "correlation_table_positive_controls.csv"), row.names = FALSE)
write.csv(negative_results$correlation_table, here(sf_dir, "correlation_table_negative_controls.csv"), row.names = FALSE)
write.csv(housekeeping_results$correlation_table, here(sf_dir, "correlation_table_housekeeping_genes.csv"), row.names = FALSE)


# =========================================
# 10.5 Normalización adicional por Size Factors
# =========================================
original_data <- exprs(nanoStringData)
norm_data <- exprs(nanoStringData_norm)

calculate_size_factors <- function(counts) {
  log_geo_means <- rowMeans(log(counts))
  apply(counts, 2, function(col) {
    exp(median((log(col) - log_geo_means)[is.finite(log_geo_means)]))
  })
}
size_factors <- calculate_size_factors(original_data)
final_norm_data <- sweep(norm_data, 2, size_factors, "/")

# Guardar matriz final normalizada
write.csv(final_norm_data, here(sf_dir, "final_normalized_matrix.csv"), row.names = TRUE)
# Visualization
par(mfrow = c(1, 3), mar = c(8, 4, 4, 2))
boxplot(log2(original_data + 1), main = "Original Data", las = 2, col = "lightblue")
boxplot(log2(norm_data + 1), main = "nSolver Normalized", las = 2, col = "#CC99FF")
boxplot(log2(final_norm_data + 1), main = "+ Size Factors", las = 2, col = "#FF66B2")


png("boxplots_normalization.png", width = 1800, height = 600, res = 150)

par(mfrow = c(1, 3), mar = c(8, 4, 4, 2))
boxplot(log2(original_data + 1), main = "Original Data", las = 2, col = "lightblue")
boxplot(log2(norm_data + 1), main = "nSolver Normalized", las = 2, col = "#CC99FF")
boxplot(log2(final_norm_data + 1), main = "+ Size Factors", las = 2, col = "#FF66B2")

dev.off()


# ================================
# 10.6 Correlation after Size Factor correction (genérico)
# ================================

# Crear carpeta de salida si no existe
output_dir_sf <- "Results_PostSizeFactors"
if (!dir.exists(output_dir_sf)) dir.create(output_dir_sf)

# 1. Definir clases de genes (usando la matriz corregida)
gene_data_sf <- data.frame(
  Gene = rownames(final_norm_data),
  CodeClass = ifelse(startsWith(rownames(final_norm_data), "Endogenous_"), "Endogenous",
             ifelse(startsWith(rownames(final_norm_data), "Negative_"), "Negative",
             ifelse(startsWith(rownames(final_norm_data), "Positive_"), "Positive",
             ifelse(startsWith(rownames(final_norm_data), "Housekeeping_"), "Housekeeping",
                    "Otro")))),
  row.names = rownames(final_norm_data)
)

# Guardar datos corregidos (batch + size factors)
write.csv(
  final_norm_data,
  file = file.path(output_dir_sf, "datos_corregidos_sizefactors.csv"),
  row.names = TRUE
)

# Función para extraer identificador corto entre los últimos dos "_"
extract_sample_id <- function(full_names) {
  sapply(strsplit(full_names, "_"), function(x) {
    if(length(x) >= 2) return(x[length(x)-1]) else return(full_names)
  })
}

# Función principal para analizar cada clase de genes
analyze_gene_class_sf <- function(expr_matrix, gene_annotations, gene_class, title_name) {
  
  if (!"CodeClass" %in% colnames(gene_annotations)) {
    stop("El dataframe gene_annotations debe contener la columna 'CodeClass'")
  }
  
  # Preparación de datos
  counts_totales <- colSums(expr_matrix)
  class_genes <- rownames(gene_annotations)[gene_annotations$CodeClass == gene_class]
  class_expr <- expr_matrix[class_genes, , drop = FALSE]
  
  # Acortar nombres de muestras
  short_names <- extract_sample_id(colnames(class_expr))
  
  # Boxplot de expresión por muestra
  df_box <- as.data.frame(t(class_expr)) %>% 
    tibble::rownames_to_column("Muestra") %>% 
    mutate(MuestraShort = extract_sample_id(Muestra)) %>% 
    tidyr::pivot_longer(-c(Muestra, MuestraShort), names_to = "Gene", values_to = "Expression")
  
  p_box <- ggplot(df_box, aes(x = MuestraShort, y = Expression, fill = MuestraShort)) +
    geom_boxplot(alpha = 0.8, outlier.shape = NA) +
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.5) +
    scale_y_log10() +
    labs(
      title = paste("Expresión de", title_name, "(Post-Corrección)"),
      x = "Muestra",
      y = "Expresión (log10)"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
          legend.position = "none") +
    scale_fill_manual(values = color_palette)
  
  # Correlación con counts totales
  corr_data <- data.frame(
    Sample = short_names,
    TotalCounts = counts_totales[colnames(class_expr)],
    t(class_expr)
  ) %>% 
    tidyr::pivot_longer(-c(Sample, TotalCounts), names_to = "Gene", values_to = "Expression") %>% 
    dplyr::group_by(Gene) %>% 
    dplyr::mutate(
      Correlation = cor(TotalCounts, Expression, method = "spearman"),
      Label = paste0("r = ", round(Correlation, 2))
    ) %>% dplyr::ungroup()
  
  label_pos <- corr_data %>%
    dplyr::group_by(Gene) %>%
    dplyr::summarise(
      Correlation = dplyr::first(Correlation),
      Label = dplyr::first(Label),
      TotalCounts = max(TotalCounts) * 0.7,
      Expression = quantile(Expression, 0.8)
    )
  
  p_cor <- ggplot(corr_data, aes(x = TotalCounts, y = Expression, color = Gene)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_smooth(method = "lm", se = FALSE, linewidth = 0.8) +
    geom_text(
      data = label_pos,
      aes(label = Label),
      hjust = 0, size = 4, fontface = "bold", show.legend = FALSE
    ) +
    scale_x_log10() +
    scale_y_log10() +
    labs(
      title = paste("Correlación:", title_name, "vs. Counts Totales"),
      subtitle = "Post-corrección",
      x = "Counts Totales (log10)",
      y = "Expresión (log10)",
      color = title_name
    ) +
    theme_bw() +
    theme(panel.grid.minor = element_blank())
  
  # Tabla de correlación
  cor_table <- corr_data %>% 
    dplyr::distinct(Gene, Correlation) %>% 
    dplyr::arrange(desc(abs(Correlation))) %>% 
    dplyr::mutate(Correlation = round(Correlation, 3))
  
  list(
    boxplot = p_box,
    correlation_plot = p_cor,
    correlation_table = cor_table,
    expression_matrix = class_expr
  )
}

# Ejecutar análisis para cada clase de genes
results_sf <- list(
  positive = analyze_gene_class_sf(final_norm_data, gene_data_sf, "Positive", "Controles Positivos"),
  housekeeping = analyze_gene_class_sf(final_norm_data, gene_data_sf, "Housekeeping", "Genes Housekeeping"),
  negative = analyze_gene_class_sf(final_norm_data, gene_data_sf, "Negative", "Controles Negativos")
)

# Mostrar tablas en consola
cat("\n=== Tabla de correlación para Controles Positivos ===\n")
print(results_sf$positive$correlation_table)
cat("\n=== Tabla de correlación para Controles Negativos ===\n")
print(results_sf$negative$correlation_table)
cat("\n=== Tabla de correlación para Genes Housekeeping ===\n")
print(results_sf$housekeeping$correlation_table)

# Exportar plots y tablas a la carpeta genérica
library(gridExtra)
library(grid)
library(ggplot2)

# Tabla gráfica Housekeeping
tabla_grafica <- tableGrob(results_sf$housekeeping$correlation_table)
png(file.path(output_dir_sf, "tabla_correlacion_housekeeping.png"), width = 800, height = 600)
grid.draw(tabla_grafica)
dev.off()

# Guardar todos los plots y tablas usando file.path()
# Controles positivos
ggsave(file.path(output_dir_sf, "correlation_positive_controls.png"), plot = results_sf$positive$correlation_plot, width = 8, height = 6, dpi = 300)
ggsave(file.path(output_dir_sf, "correlation_positive_controls.pdf"), plot = results_sf$positive$correlation_plot, width = 8, height = 6)
ggsave(file.path(output_dir_sf, "boxplot_positive_controls.png"), plot = results_sf$positive$boxplot, width = 10, height = 6, dpi = 300)
ggsave(file.path(output_dir_sf, "boxplot_positive_controls.pdf"), plot = results_sf$positive$boxplot, width = 10, height = 6)
write.csv(results_sf$positive$correlation_table, file.path(output_dir_sf, "correlation_table_positive_controls.csv"), row.names = FALSE)

# Controles negativos
ggsave(file.path(output_dir_sf, "correlation_negative_controls.png"), plot = results_sf$negative$correlation_plot, width = 8, height = 6, dpi = 300)
ggsave(file.path(output_dir_sf, "correlation_negative_controls.pdf"), plot = results_sf$negative$correlation_plot, width = 8, height = 6)
ggsave(file.path(output_dir_sf, "boxplot_negative_controls.png"), plot = results_sf$negative$boxplot, width = 10, height = 6, dpi = 300)
ggsave(file.path(output_dir_sf, "boxplot_negative_controls.pdf"), plot = results_sf$negative$boxplot, width = 10, height = 6)
write.csv(results_sf$negative$correlation_table, file.path(output_dir_sf, "correlation_table_negative_controls.csv"), row.names = FALSE)

# Genes Housekeeping
ggsave(file.path(output_dir_sf, "correlation_housekeeping_genes.png"), plot = results_sf$housekeeping$correlation_plot, width = 10, height = 6, dpi = 300)
ggsave(file.path(output_dir_sf, "correlation_housekeeping_genes.pdf"), plot = results_sf$housekeeping$correlation_plot, width = 10, height = 6)
ggsave(file.path(output_dir_sf, "boxplot_housekeeping_genes.png"), plot = results_sf$housekeeping$boxplot, width = 10, height = 6, dpi = 300)
write.csv(results_sf$housekeeping$correlation_table, file.path(output_dir_sf, "correlation_table_housekeeping_genes.csv"), row.names = FALSE)
``` 


```{r Batch Effect}
# ----------------------------
# 11. Batch Effect 
# ----------------------------

# Cargar paquetes necesarios
pacman::p_load(
  ggplot2, 
  ggrepel,
  pheatmap,
  RColorBrewer,
  limma,
  lme4,
  variancePartition,
  dplyr,
  reshape2,
  Biobase,
  gridExtra,
  patchwork
)

# Configurar directorio de salida
output_dir <- "batch_effect_analysis"
if (!dir.exists(output_dir)) dir.create(output_dir)

# Extraer matriz de expresión (ExpressionSet o data frame/matrix)
expr_matrix <- if (is(final_norm_data, "ExpressionSet")) {
  Biobase::exprs(final_norm_data)
} else {
  as.matrix(final_norm_data)
}

# Limpiar nombres de muestra
clean_sample_names <- colnames(expr_matrix)

# Crear metadatos genéricos
# Ajusta si tienes columnas de batch o tipo conocidas
metadata <- data.frame(
  SampleID = clean_sample_names,
  OriginalID = clean_sample_names,
  Batch = factor(rep("Batch1", ncol(expr_matrix))),  # Temporal: todos en mismo batch
  Type = factor(rep("Sample", ncol(expr_matrix))),
  row.names = clean_sample_names
)

write.csv(metadata, file.path(output_dir, "metadata.csv"))
```

```{r exploratory analysis}
# ----------------------------
# 12. Análisis exploratorio
# ----------------------------

# PCA
pca_result <- prcomp(t(expr_matrix), scale. = TRUE)
pca_vars <- round(100 * pca_result$sdev^2 / sum(pca_result$sdev^2), 1)

pca_data <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  Sample = clean_sample_names
)

pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, label = Sample)) +
  geom_point(size = 3, alpha = 0.8) +
  geom_text_repel(size = 3) +
  labs(
    title = "PCA de todas las muestras",
    x = paste0("PC1 (", pca_vars[1], "%)"),
    y = paste0("PC2 (", pca_vars[2], "%)")
  ) +
  theme_minimal()

ggsave(file.path(output_dir, "pca_plot.png"), pca_plot, width = 10, height = 8)

# Heatmap de correlación
cor_matrix <- cor(expr_matrix, use = "complete.obs")
rownames(cor_matrix) <- colnames(cor_matrix) <- clean_sample_names

heatmap_plot <- pheatmap(
  cor_matrix,
  color = colorRampPalette(rev(brewer.pal(9, "RdBu")))(100),
  main = "Matriz de correlación entre muestras",
  show_rownames = TRUE,
  show_colnames = FALSE,
  fontsize_row = 6,
  fontsize_col = 6,
  filename = file.path(output_dir, "correlation_heatmap.png")
)

# Boxplot de expresión de muestra (subset de genes si es necesario)
set.seed(123)
n_genes <- min(50, nrow(expr_matrix))
expr_subset <- expr_matrix[sample(1:nrow(expr_matrix), n_genes), ]
expr_melted <- reshape2::melt(expr_subset)
expr_melted$Sample <- rep(clean_sample_names, each = n_genes)

boxplot <- ggplot(expr_melted, aes(x = Sample, y = value)) +
  geom_boxplot(outlier.size = 0.5, fill = "steelblue") +
  labs(title = paste("Distribución de expresión de", n_genes, "genes seleccionados")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(file.path(output_dir, "expression_boxplots.png"), boxplot, width = 10, height = 6)


# ----------------------------
# 12.1 Análisis estadístico limma 
# ----------------------------

# Temporal: todos en un batch, ajuste genérico
design <- model.matrix(~ 1, data = metadata)
fit <- lmFit(expr_matrix, design) |> eBayes()
batch_results <- topTable(fit, number = Inf, sort.by = "none")

pval_plot <- ggplot(batch_results, aes(x = P.Value)) +
  geom_histogram(bins = 30, fill = "steelblue") +
  labs(title = "Distribución de p-valores (batch effect)") +
  theme_minimal()
ggsave(file.path(output_dir, "pvalue_distribution.png"), pval_plot, width = 8, height = 6)


# ----------------------------
# 12.2 KDE Plot post-normalización
# ----------------------------
exprs_long <- as.data.frame(expr_matrix) %>% 
  tibble::rownames_to_column("Gene") %>% 
  pivot_longer(-Gene, names_to = "Sample", values_to = "Expression")

kde_plot <- ggplot(exprs_long, aes(x = Expression, color = Sample)) +
  geom_density(linewidth = 1, alpha = 0.7) +
  geom_rug(alpha = 0.3) +
  labs(title = "Distribución de expresión post-normalización", x = "Expresión", y = "Densidad") +
  theme_minimal()

ggsave(file.path(output_dir, "KDE_post_sf.png"), kde_plot, width = 12, height = 8)

# ----------------------------
# 12.3 Outliers 
# ----------------------------
cor_matrix <- cor(expr_matrix, method = "spearman")
mean_cor <- rowMeans(cor_matrix)
cor_threshold <- 0.6
outlier_flag <- ifelse(mean_cor < cor_threshold, "Outlier", "Normal")

annotation_df <- data.frame(
  Mean_Correlation = mean_cor,
  Status = outlier_flag
)
rownames(annotation_df) <- clean_sample_names

pheatmap(cor_matrix,
         color = colorRampPalette(brewer.pal(9, "YlOrRd"))(100),
         annotation_row = annotation_df,
         annotation_col = annotation_df,
         show_rownames = TRUE,
         show_colnames = FALSE,
         fontsize = 8,
         main = paste("Correlación Spearman | Outliers (cor <", cor_threshold, ")"),
         filename = file.path(output_dir, "Heatmap_Correlacion_Spearman.png"))

# Histograma de correlaciones promedio
png(file.path(output_dir, "Histograma_Correlaciones_Promedio.png"), width = 1000, height = 800)
hist(mean_cor, breaks = 30, col = "lightblue",
     main = "Distribución de correlaciones promedio",
     xlab = "Correlación promedio", ylab = "Frecuencia")
abline(v = cor_threshold, col = "red", lty = 2)
dev.off()


```



